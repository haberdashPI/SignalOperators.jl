using Random

# helpers
astuple(x::Number) = (x,)
astuple(x::Tuple) = x
astuple(x) = error("Function must return number or tuple of numbers.")
ntuple_T(::Type{<:NTuple{<:Any,T}}) where T = T
ntuple_N(::Type{<:NTuple{N}}) where N = N

# signals can be generated by functions of time
struct SignalFunction{Fn,Fr,El,T,Fs} <: AbstractSignal{El}
    fn::Fn
    first::El
    ω::Fr
    ϕ::Float64
    framerate::Fs
    function SignalFunction(fn::Fn,first::El,ω::Fr,ϕ,
        sr::Fs=missing) where {Fn,El,Fr,Fs}

        new{Fn,Fr,El,ntuple_T(El),Fs}(fn,first,ω,ϕ,sr)
    end
end
SignalTrait(::Type{<:SignalFunction{<:Any,<:Any,<:Any,T,Fs}}) where {T,Fs} =
    IsSignal{T,Fs,InfiniteLength}()
nchannels(x::SignalFunction) = ntuple_N(typeof(x.first))
tagged_nframes(x::SignalFunction) = tag(inflen)
framerate(x::SignalFunction) = x.framerate
EvalTrait(x::SignalFunction) = ComputedSignal()

function Base.show(io::IO, ::MIME"text/plain",x::SignalFunction)
    if ismissing(x.ω) && iszero(x.ϕ)
        write(io,string(x.fn))
        show_fs(io,x)
    else
        write(io,"Signal(")
        write(io,string(x.fn))
        !ismissing(x.ω) && write(io,",ω=",string(x.ω))
        !iszero(x.ϕ) && write(io,",ϕ=",string(x.ϕ),"π")
        write(io,")")
        show_fs(io,x)
    end
end

# TODO: handle functions with more than one output
# NOTE: this can probably be done by making arrays of number-tuples
# a type of signal
st(x::SignalFunction) = ((1:n) .- 1) ./ x.framerate
sink(x::SignalFunction, ::IsSignal, n) =
    ApplyArray(x.fn, 2π*((st(x)*x.ω + x.ϕ) % 1.0))
sink(x::SignalFunction{<:Any, Missing}, ::IsSignal, n) =
    ApplyArray(x.fn, st(t) + x.ϕ)
sink(x::SignalFunction{typeof(sin)}, ::IsSignal, n) =
    ApplyArray(sinpi, 2*(st(t)/x.framerate*x.ω + x.ϕ))
sink(x::SignalFunction{typeof(sin),Missing}, ::IsSignal, n) =
    ApplyArray(sinpi, 2*(st(t)/x.framerate + x.ϕ))

ToFramerate(x::SignalFunction,::IsSignal,::ComputedSignal,fs;blocksize) =
    SignalFunction(x.fn,x.first,x.ω,x.ϕ,coalesce(inHz(Float64,fs),x.framerate))

abstract type Functor
end

"""
## Functions

    Signal(fn,[framerate];[ω/frequency],[ϕ/phase])

Functions can define infinite length signals of known or unknown frame rate.
The function `fn` can either return a number or, for multi-channel signals,
a tuple of values.

The input to `fn` is either a phase value or a time value. If a frequency is
specified (using either the ω or frequency keyword), the input to `fn` will
be a phase value in radians, ranging from 0 to 2π. If no frequency is
specified the value passed to `fn` is the time in seconds. Specifying phase
(by the ϕ or phase keyword) will first add that value to the input before
passing it to `fn`. When frequency is specified, the phase is assumed to be
in units of radians (but you can also pass degrees by using `°` or a unit of
time (e.g. `s` for seconds)). When frequency is not specified the phase
is assumed to be in units of seconds.

"""
function Signal(fn::Union{Function,Functor},
    framerate::Union{Missing,Number}=missing;
    ω=missing,frequency=ω,ϕ=0,phase=ϕ)

    SignalFunction(fn,astuple(fn(0.0)),inHz(ω),
        ismissing(ω) ? inseconds(Float64,ϕ) :
            inradians(Float64,ϕ,ω)/2π,
        inHz(Float64,framerate))
end

struct RandFn{R}
    rng::R
end
Base.string(x::RandFn) = "randn"

"""

If `fn == randn` no frequency or phase can be specified. Instead there is a
single keyword argument, `rng`, which allows you to specify the random number
generator; `rng` defaults to `Random.GLOBAL_RNG`.

"""
# TODO: change type to Array, then we can default
# to a fallback, but array types can specialize on the signal type
sink(x:::SignalFunction{<:RandFn,Missing}, ::IsSiganl, n) = randn(x.fn.rng, n)
