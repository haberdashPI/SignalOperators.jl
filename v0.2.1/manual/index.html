<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SignalOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SignalOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Manual</a><ul class="internal"><li><a class="toctext" href="#Key-concepts-1">Key concepts</a></li><li><a class="toctext" href="#Signal-generation-1">Signal generation</a></li><li><a class="toctext" href="#Signal-inspection-1">Signal inspection</a></li><li><a class="toctext" href="#Signal-operators-1">Signal operators</a></li></ul></li><li><a class="toctext" href="../custom/">Custom Signals</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Manual</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/SignalOperators.jl/blob/master/docs/src/manual.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><p>SignalOperators is composed of a set of functions for generating, inspecting and operating over signals. Here, a &quot;signal&quot; is represented as a number of channels (e.g. left and right speaker) with values (e.g. <code>Float64</code>) sampled regularly in time (e.g. every 100th of a second, or 100 Hz).</p><h2><a class="nav-anchor" id="Key-concepts-1" href="#Key-concepts-1">Key concepts</a></h2><p>There are several important concepts employed across the public interface. Let&#39;s step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts.</p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz) |&gt; until(5s) |&gt; ramp |&gt; normpower |&gt; amplify(-20dB)</code></pre><p>This example creates a 1 kHz pure-tone (sine wave) that lasts 5 seconds. Its amplitude is 20 dB lower than a signal with unit 1 power.</p><p>There are a few things going on here: piping, the use of units, infinite length signals, and unspecified sample rates.</p><h3><a class="nav-anchor" id="Piping-1" href="#Piping-1">Piping</a></h3><p>Almost all of the functions implemented in SignalOperators can be piped. This means that instead of passing the first argument to a function, you can pipe it using <code>|&gt;</code>. For example, the two statements below have the same meaning.</p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz) |&gt; until(5s)
sound1 = until(signal(sin,ω=1kHz),5s)</code></pre><p>The use of piping makes it easier to read the sequence of operations that are performed on the signal.</p><h3><a class="nav-anchor" id="Units-1" href="#Units-1">Units</a></h3><p>In any place where a function needs a time or a frequency, it can be specified in appropriate units. There are many places where units can be passed. They all have a default assumed unit, if a plain number without units is passed. The default units are seconds, Hertz, and radians as appropriate for the given argument.</p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz)
sound1 = signal(sin,ω=1000)</code></pre><p>Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants, you must call <code>using SignalOperators.Units</code>. This exports the following units: <code>samples</code>, <code>ksamples</code>, <code>Hz</code>, <code>kHz</code> <code>s</code>, <code>ms</code>, <code>rad</code>, <code>°</code>, and <code>dB</code>. You can just include the ones you want using e.g. <code>using SignalOperators.Units: Hz</code>, or you can include more by adding the <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful</code></a> package to your project and adding the desired units from there. For example, <code>using Unitful: MHz</code> would include mega-Hertz frequencies (not usually useful for signals that are sounds). Most of the default units have been re-exported from <code>Unitful</code>. However, the <code>samples</code> unit and its derivatives (e.g. <code>ksamples</code>) are unique  to the SignalOperators package. They allow you to specify the time in terms of the number of samples: e.g. at a sample rate of 100 Hz, <code>2s == 200samples</code>. Other powers of ten are represented for <code>samples</code>, (e.g. <code>Msamples</code> for mega-samples) but they are not exported (e.g. you would have to call <code>SignalOperators.Units: Msamples</code> before using <code>20Msamples</code>).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>You can find the available powers-of-ten for units in <code>Unitful.prefixdict</code></p></div></div><p>Note that the output of functions to inspect a signal (e.g. <code>duration</code>, <code>samplerate</code>) are bare values in the default unit (e.g. seconds or Hertz). No unit is explicitly provided by the return value.</p><h4><a class="nav-anchor" id="Decibels-1" href="#Decibels-1">Decibels</a></h4><p>You can pass an amplification value as a unitless or a unitful value in <code>dB</code>; a unitless value is not assumed to be in decibels. Instead, it&#39;s assumed to be the actual ratio by which you wish to multiply the signal. For example, <code>amplify(x,2)</code> will make <code>x</code> twice as loud.</p><h3><a class="nav-anchor" id="Infinite-lengths-1" href="#Infinite-lengths-1">Infinite lengths</a></h3><p>Some of the ways you can define a signal lead to an infinite length signal. You cannot store an infinite signal. It is represented as a function of some kind. Operations on signals are generally lazy, meaning the samples of the signal aren&#39;t computed until necessary. To allow actual data to be created from a signal, you have to specify the length, using <a href="../reference/#SignalOperators.until"><code>until</code></a>. For example, when using <code>signal(sin)</code>, the signal is an infinite length sine wave. That&#39;s why, in the example above, we use <a href="../reference/#SignalOperators.until"><code>until</code></a> to specify the length, as follows.</p><pre><code class="language-julia">signal(sin,ω=1kHz) |&gt; until(5s)</code></pre><p>Infinite lengths are represented as the value <a href="../reference/#SignalOperators.inflen"><code>inflen</code></a>. This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc...</p><h3><a class="nav-anchor" id="Unspecified-sample-rates-1" href="#Unspecified-sample-rates-1">Unspecified sample rates</a></h3><p>You may notice that the above signal has no defined sample rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined sample rate, the unspecified sample rate will be resolved to that same rate (see signal promotion, below). If there is no defined sample rate by the time you call <a href="../reference/#SignalOperators.sink"><code>sink</code></a>, you can specify it then.</p><h3><a class="nav-anchor" id="Sinking-1" href="#Sinking-1">Sinking</a></h3><p>Once you have defined a signal, you can create some concrete sequence of samples from it. This is done using <a href="../reference/#SignalOperators.sink"><code>sink</code></a>. When <code>sink</code> is simply passed a signal, the resulting value is itself a signal. This means you can continue to processes it with more operators. The function <a href="../reference/#SignalOperators.sink"><code>sink</code></a> can also write data to a file. Sink must consume a finite-length signal. To store the five second signal in the above example to &quot;example.wav&quot; we could write the following.</p><pre><code class="language-julia">sound1 |&gt; sink(&quot;example.wav&quot;)</code></pre><p>In this case <code>sound1</code> had no defined sample rate, so the default sample rate of 44.1khz will be used. The absence of an explicit sample rate will raise a warning.</p><h3><a class="nav-anchor" id="Signal-promotion-1" href="#Signal-promotion-1">Signal promotion</a></h3><p>A final concept, which is not as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different number of channels or different sample rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don&#39;t have to worry about the specific format of the signal, and you won&#39;t loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using <a href="../reference/#SignalOperators.tochannels"><code>tochannels</code></a> or <a href="../reference/#SignalOperators.tosamplerate"><code>tosamplerate</code></a>).</p><h2><a class="nav-anchor" id="Signal-generation-1" href="#Signal-generation-1">Signal generation</a></h2><p>There are four basic types that can be interpreted as signals: numbers, arrays, functions and files. Internally the function <a href="../reference/#SignalOperators.signal"><code>signal</code></a> is called on any object passed to a function that inspects or operates on a signal; you can call <a href="../reference/#SignalOperators.signal"><code>signal</code></a> yourself if you want to specify more information. For example, you may want to provide the exact sample rate the signal should be interpreted to have.</p><h3><a class="nav-anchor" id="Numbers-1" href="#Numbers-1">Numbers</a></h3><p>A number is treated as an infinite length signal, with unknown sample rate.</p><pre><code class="language-julia">1 |&gt; until(1s) |&gt; sink(samplerate=10Hz) == ones(10)</code></pre><h3><a class="nav-anchor" id="Arrays-1" href="#Arrays-1">Arrays</a></h3><p>A standard array is treated as a finite signal with unknown sample rate.</p><pre><code class="language-julia">rand(10,2) |&gt; sink(samplerate=10Hz) |&gt; duration == 1</code></pre><p>An <code>AxisArray</code> is treated as a finite signal with a known sample rate (and is the default output of <a href="../reference/#SignalOperators.sink"><code>sink</code></a>)</p><pre><code class="language-julia">using AxisArrays
x = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))
samplerate(x) == 10</code></pre><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><p>A single argument function of time (in seconds) can be treated as an infinite signal. It can be also be a function of radians if you specify a frequency using <code>ω</code> (or <code>frequency</code>). See <a href="../reference/#SignalOperators.signal"><code>signal</code></a>&#39;s documentation for more details.</p><pre><code class="language-julia">signal(sin,ω=1kHz) |&gt; duration |&gt; isinf == true</code></pre><p>A small exception to this is <code>randn</code>. It can be used directly as a signal with unknown sample rate.</p><pre><code class="language-julia">randn |&gt; duration == isinf</code></pre><h3><a class="nav-anchor" id="Files-1" href="#Files-1">Files</a></h3><p>A file is interpreted as a WAV audio file to be loaded into memory. You must include the <code>WAV</code> package for this to work.</p><pre><code class="language-julia">using WAV
x = signal(&quot;example.wav&quot;)</code></pre><h2><a class="nav-anchor" id="Signal-inspection-1" href="#Signal-inspection-1">Signal inspection</a></h2><p>You can examine the properties of a signal using <a href="../reference/#SignalOperators.nsamples"><code>nsamples</code></a>, <a href="../reference/#SignalOperators.nchannels"><code>nchannels</code></a>, <a href="../reference/#SignalOperators.samplerate"><code>samplerate</code></a>, and <a href="../reference/#SignalOperators.duration"><code>duration</code></a>.</p><h2><a class="nav-anchor" id="Signal-operators-1" href="#Signal-operators-1">Signal operators</a></h2><p>There are several categories of signal operators: extending, cutting, filtering, ramping, and mapping.</p><h3><a class="nav-anchor" id="Extending-1" href="#Extending-1">Extending</a></h3><p>You can extend a signal using <a href="../reference/#SignalOperators.pad"><code>pad</code></a> or <a href="../reference/#SignalOperators.append"><code>append</code></a>. A padded signal becomes infinite by appending the signal by a repeated value, usually <code>one</code> or <code>zero</code>. You can append two or more signals (or <a href="../reference/#SignalOperators.prepend"><code>prepend</code></a>) so they occur one after another.</p><pre><code class="language-julia">pad(x,zero) |&gt; duration |&gt; isinf == true
append(x,y,z) |&gt; duration == duration(x) + duration(y) + duration(z)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>You cannot append more than one new signal within a pipe. That is, the following will throw an error.</p><pre><code class="language-julia"># Don&#39;t do this!
x |&gt; append(y,z)</code></pre><p>This is because <code>append(y,z)</code> does not return a function to be piped (as <code>append(y)</code> does). It returns a signal with <code>y</code> followed by <code>z</code>. You can instead call this as follows.</p><pre><code class="language-julia"># This will do what you want!
x |&gt; append(y) |&gt; append(z)</code></pre></div></div><h3><a class="nav-anchor" id="Cutting-1" href="#Cutting-1">Cutting</a></h3><p>You can cut signals apart, removing either the end of the signal (<a href="../reference/#SignalOperators.until"><code>until</code></a>) or the beginning (<a href="../reference/#SignalOperators.after"><code>after</code></a>). The operations are exact compliments of one another.</p><pre><code class="language-julia">append(until(x,2s),after(x,2s)) |&gt; nsamples == nsamples(x)</code></pre><h3><a class="nav-anchor" id="Filtering-1" href="#Filtering-1">Filtering</a></h3><p>You can filter signals, removing undesired frequencies using <a href="../reference/#SignalOperators.lowpass"><code>lowpass</code></a>, <a href="../reference/#SignalOperators.highpass"><code>highpass</code></a>, <a href="../reference/#SignalOperators.bandpass"><code>bandpass</code></a>, <a href="../reference/#SignalOperators.bandstop"><code>bandstop</code></a> and <a href="../reference/#SignalOperators.filtersignal"><code>filtersignal</code></a>. The latter allows the use of any arbitrary filter defined using <code>DSP</code>.</p><pre><code class="language-julia">signal(randn) |&gt; lowpass(20Hz)</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>If you write <code>using DSP</code> you will have to also write <code>dB = SignalOperators.Units.dB</code> if you want to make use of the proper meaning of <code>dB</code> for <code>SignalOperators</code>: <code>DSP</code> also defines <code>dB</code>.</p></div></div><p>An unusual filter is <a href="../reference/#SignalOperators.normpower"><code>normpower</code></a>: it computes the root mean squared power of the signal and then normalizes each sample by that value.</p><h3><a class="nav-anchor" id="Ramping-1" href="#Ramping-1">Ramping</a></h3><p>A ramp allows for smooth transitions between 0 amplitude and the full amplitude of the signal. It is useful to avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.</p><pre><code class="language-julia">signal(sin,ω=2kHz) |&gt; until(5s) |&gt; ramp</code></pre><p>You can ramp only the start of a signal (<a href="../reference/#SignalOperators.rampon"><code>rampon</code></a>), or the end of it (<a href="../reference/#SignalOperators.rampoff"><code>rampoff</code></a>) and you can use ramps to create a smooth transition between two signals (<a href="../reference/#SignalOperators.fadeto"><code>fadeto</code></a>).</p><h3><a class="nav-anchor" id="Mapping-1" href="#Mapping-1">Mapping</a></h3><p>Probably the most powerful operator is <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a>. It works a lot like <code>map</code> but automatically promotes the signals, as with all operators, <em>and</em> it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest <em>finite</em>-length signal.</p><pre><code class="language-julia">a = signal(sin,ω=2kHz) |&gt; until(2s)
b = signal(sin,ω=1kHz) |&gt; until(3s)
a_minus_b = mapsignal(-,a,b)</code></pre><p>The function <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a> cannot itself be piped, due to ambiguity in the arguments, but shortcuts for this function have been provided for addition (<a href="../reference/#SignalOperators.mix"><code>mix</code></a>) and multiplication (<a href="../reference/#SignalOperators.amplify"><code>amplify</code></a>), the two most common operations, and these two shortcuts have piped versions available.</p><pre><code class="language-julia">a_plus_b = a |&gt; mix(b)
a_times_b = a |&gt; amplify(b)</code></pre><p>You can also add or select out channels using <a href="../reference/#SignalOperators.addchannel"><code>addchannel</code></a> and <a href="../reference/#SignalOperators.channel"><code>channel</code></a>, which are defined in terms of calls to <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a>. These use a variant of <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a> where the keyword <code>bychannel</code> is set to <code>false</code> (see <code>mapsignal</code>&#39;s documentation for details).</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../custom/"><span class="direction">Next</span><span class="title">Custom Signals</span></a></footer></article></body></html>
