<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SignalOperators.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SignalOperators.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Key-concepts-1"><span>Key concepts</span></a></li><li><a class="tocitem" href="#Signal-generation-1"><span>Signal generation</span></a></li><li><a class="tocitem" href="#Signal-inspection-1"><span>Signal inspection</span></a></li><li><a class="tocitem" href="#Signal-operators-1"><span>Signal operators</span></a></li></ul></li><li><a class="tocitem" href="../custom_signal/">Custom Signals</a></li><li><a class="tocitem" href="../custom_sink/">Custom Sinks</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/haberdashPI/SignalOperators.jl/blob/master/docs/src/manual.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual-1"><a class="docs-heading-anchor" href="#Manual-1">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-1" title="Permalink"></a></h1><p>SignalOperators is composed of a set of functions for generating, inspecting and operating over signals. Here, a &quot;signal&quot; is represented as a number of frames: each frame contains some number of channels (e.g. left and right speaker) with a sampled value (e.g. <code>Float64</code>) for each channel. The values are sampled regularly in time (e.g. every 100th of a second, or 100 Hz); this is referred to as the frame rate.</p><h2 id="Key-concepts-1"><a class="docs-heading-anchor" href="#Key-concepts-1">Key concepts</a><a class="docs-heading-anchor-permalink" href="#Key-concepts-1" title="Permalink"></a></h2><p>There are several important concepts employed across the public interface. Let&#39;s step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts.</p><pre><code class="language-julia">sound1 = Signal(sin,ω=1kHz) |&gt; Until(5s) |&gt; Ramp |&gt; Normpower |&gt; Amplify(-20dB)</code></pre><p>This example creates a 1 kHz pure-tone (sine wave) that lasts 5 seconds. Its amplitude is 20 dB lower than a signal with unit 1 power.</p><p>There are a few things going on here: piping, the use of units, lazy evaluation, infinite length signals and unspecified frame rates.</p><h3 id="Piping-1"><a class="docs-heading-anchor" href="#Piping-1">Piping</a><a class="docs-heading-anchor-permalink" href="#Piping-1" title="Permalink"></a></h3><p>Almost all of the operators in SignalOperators can be piped. This means that instead of passing the first argument you can pipe it using <code>|&gt;</code>. For example, the two statements below have the same meaning.</p><pre><code class="language-julia">sound1 = Signal(sin,ω=1kHz) |&gt; Until(5s)
sound1 = Until(Signal(sin,ω=1kHz),5s)</code></pre><p>The use of piping makes it easier to read the sequence of operations that are performed on the signal.</p><h3 id="Units-1"><a class="docs-heading-anchor" href="#Units-1">Units</a><a class="docs-heading-anchor-permalink" href="#Units-1" title="Permalink"></a></h3><p>In any place where a function needs a time or a frequency, it can be specified in appropriate units. There are many places where units can be passed. They all have a default assumed unit if a plain number without units is passed. The default units are seconds, Hertz, and radians as appropriate for the given argument.</p><pre><code class="language-julia">sound1 = Signal(sin,ω=1kHz)
sound1 = Signal(sin,ω=1000)</code></pre><p>Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants, you must call <code>using SignalOperators.Units</code>. This exports the following units: <code>frames</code>, <code>kframes</code>, <code>Hz</code>, <code>kHz</code> <code>s</code>, <code>ms</code>, <code>rad</code>, <code>°</code>, and <code>dB</code>. You can just include the ones you want using e.g. <code>using SignalOperators.Units: Hz</code>, or you can include more by adding the <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful</code></a> package to your project and adding the desired units from there. For example, <code>using Unitful: MHz</code> would include mega-Hertz frequencies (not normally useful for sound signals). Most of the default units have been re-exported from <code>Unitful</code>. However, the <code>frames</code> unit and its derivatives (e.g. <code>kframes</code>) are unique  to the SignalOperators package. They allow you to specify the time in terms of the number of frames: e.g. at a frame rate of 100 Hz, <code>2s == 200frames</code>. Other powers of ten are represented for <code>frames</code>, (e.g. <code>Mframes</code> for mega-frames) but they are not exported (e.g. you would have to call <code>SignalOperators.Units: Mframes</code> before using <code>20Mframes</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can find the available powers-of-ten for units in <code>Unitful.prefixdict</code></p></div></div><p>Note that the output of functions to inspect a signal (e.g. <code>duration</code>, <code>framerate</code>) are bare values in the default unit (e.g. seconds or Hertz). No unit is explicitly provided by the return value.</p><h4 id="Decibels-1"><a class="docs-heading-anchor" href="#Decibels-1">Decibels</a><a class="docs-heading-anchor-permalink" href="#Decibels-1" title="Permalink"></a></h4><p>You can pass an amplification value as a unitless or a unitful value in <code>dB</code>; a unitless value is not assumed to be in decibels. Instead, it&#39;s assumed to be the actual ratio by which you wish to multiply the signal. For example, <code>Amplify(x,2)</code> will make <code>x</code> twice as loud while <code>Amplify(x,2dB)</code> will increase the amplitude by two decibells.</p><h3 id="Lazy-Evaluation-1"><a class="docs-heading-anchor" href="#Lazy-Evaluation-1">Lazy Evaluation</a><a class="docs-heading-anchor-permalink" href="#Lazy-Evaluation-1" title="Permalink"></a></h3><p>To ensure efficient signal generation, signal operators are lazy: no computations are performed until the actual signal data is requested. This lazy quality is reflected in the captilization of the operators: conceptually the operators define some new signal object which can be used to generate frames of data based on the input signal or signals.</p><p>To request evaluation of a lazy signal you can use an array constructor: <code>Array</code>, <code>AxisArray</code>, <code>DimensinoalArray</code> or <code>SampleBuf</code>, or you can call the more general methods <a href="../reference/#SignalOperators.sink"><code>sink</code></a> or <a href="../reference/#SignalOperators.sink!"><code>sink!</code></a>. The result of <code>sink</code> is itself a (non-lazy) signal. You can always specify the return type of <code>sink</code>, but by default it tries to maintain the same representation of the signal or signals used as input, favoring the earlier arguments over later arguments. For example <code>sink(SampleBuf(rand(10,2),10) |&gt; Mix(1)) isa SampleBuf</code>.</p><p>The function <a href="../reference/#SignalOperators.sink"><code>sink</code></a> can also write data to a file. To store the five second signal in the above example to &quot;example.wav&quot; we could write the following.</p><pre><code class="language-julia">sound1 |&gt; ToFramerate(44.1kHz) |&gt; sink(&quot;example.wav&quot;)</code></pre><p>In this case <code>sound1</code> had no defined frame rate, so we must specify one using <a href="../reference/#SignalOperators.ToFramerate"><code>ToFramerate</code></a>.</p><h4 id="Non-lazy-operators-1"><a class="docs-heading-anchor" href="#Non-lazy-operators-1">Non-lazy operators</a><a class="docs-heading-anchor-permalink" href="#Non-lazy-operators-1" title="Permalink"></a></h4><p>If you prefer the result of an operator to be non-lazy, so you don&#39;t have to call <code>sink</code> first, you can make use the lower case versions of the operators. These operators do not allow for piping, as this would typically be quite inefficient. If you want to combine multiple operators, they should normally be evaluated lazily.</p><h3 id="Infinite-lengths-1"><a class="docs-heading-anchor" href="#Infinite-lengths-1">Infinite lengths</a><a class="docs-heading-anchor-permalink" href="#Infinite-lengths-1" title="Permalink"></a></h3><p>Some of the ways you can define a signal lead to an infinite length signal. To allow for calls to <code>sink</code>, you have to specify the length, using <a href="../reference/#SignalOperators.Until"><code>Until</code></a>. For example, when using <code>Signal(sin)</code>, the signal is an infinite length sine wave. That&#39;s why, in the example above, we use <a href="../reference/#SignalOperators.Until"><code>Until</code></a> to specify the length, as follows.</p><pre><code class="language-julia">Signal(sin,ω=1kHz) |&gt; Until(5s)</code></pre><p>Infinite lengths are represented as the value <a href="../reference/#SignalOperators.inflen"><code>inflen</code></a> (e.g. when calling <a href="../reference/#SignalOperators.nframes"><code>nframes</code></a>). This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc...</p><h3 id="Unspecified-frame-rates-1"><a class="docs-heading-anchor" href="#Unspecified-frame-rates-1">Unspecified frame rates</a><a class="docs-heading-anchor-permalink" href="#Unspecified-frame-rates-1" title="Permalink"></a></h3><p>You may notice that the above signal has no defined frame rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined frame rate, the unspecified frame rate will be resolved to that same rate (see signal promotion, below).</p><h3 id="Signal-promotion-1"><a class="docs-heading-anchor" href="#Signal-promotion-1">Signal promotion</a><a class="docs-heading-anchor-permalink" href="#Signal-promotion-1" title="Permalink"></a></h3><p>A final concept, which is not as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different number of channels or different frame rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don&#39;t have to worry about the specific format of the signal, and you won&#39;t loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using <a href="../reference/#SignalOperators.ToChannels"><code>ToChannels</code></a> or <a href="../reference/#SignalOperators.ToFramerate"><code>ToFramerate</code></a>).</p><h2 id="Signal-generation-1"><a class="docs-heading-anchor" href="#Signal-generation-1">Signal generation</a><a class="docs-heading-anchor-permalink" href="#Signal-generation-1" title="Permalink"></a></h2><p>There are four basic types that can be interpreted as signals: numbers, arrays, functions and files. Internally the function <a href="../reference/#SignalOperators.Signal"><code>Signal</code></a> is called on any object passed to a function that operates on a signal; you can call <a href="../reference/#SignalOperators.Signal"><code>Signal</code></a> yourself if you want to specify more information. For example, you may want to provide the exact frame rate the signal should be interpreted to have.</p><h3 id="Numbers-1"><a class="docs-heading-anchor" href="#Numbers-1">Numbers</a><a class="docs-heading-anchor-permalink" href="#Numbers-1" title="Permalink"></a></h3><p>A number is treated as an infinite length signal, with unknown frame rate.</p><pre><code class="language-julia">1 |&gt; Until(1s) |&gt; ToFramerate(10Hz) |&gt; sink == ones(10)</code></pre><h3 id="Arrays-1"><a class="docs-heading-anchor" href="#Arrays-1">Arrays</a><a class="docs-heading-anchor-permalink" href="#Arrays-1" title="Permalink"></a></h3><p>A standard array is treated as a finite signal with unknown frame rate.</p><pre><code class="language-julia">rand(10,2) |&gt; ToFramerate(10Hz) |&gt; sink |&gt; duration == 1</code></pre><p>An <code>AxisArray</code>, <code>DimesnionalArray</code> or <code>SampleBuf</code> (from <a href="https://github.com/JuliaAudio/SampledSignals.jl"><code>SampledSignals</code></a>) is treated as a finite signal with a known frame rate (and is the default output of <a href="../reference/#SignalOperators.sink"><code>sink</code></a>)</p><pre><code class="language-julia">using AxisArrays
x = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))
framerate(x) == 10</code></pre><h3 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h3><p>A single argument function of time (in seconds) can be treated as an infinite signal. It can be also be a function of radians if you specify a frequency using <code>ω</code> (or <code>frequency</code>). See <a href="../reference/#SignalOperators.Signal"><code>Signal</code></a>&#39;s documentation for more details.</p><pre><code class="language-julia">Signal(sin,ω=1kHz) |&gt; duration |&gt; isinf == true</code></pre><p>A small exception to this is <code>randn</code>. It can be used directly as a signal with unknown frame rate.</p><pre><code class="language-julia">randn |&gt; duration == isinf</code></pre><h3 id="Files-1"><a class="docs-heading-anchor" href="#Files-1">Files</a><a class="docs-heading-anchor-permalink" href="#Files-1" title="Permalink"></a></h3><p>A file is interpreted as an audio file to be loaded into memory. You must include the <code>WAV</code> or <code>LibSndFile</code> package for this to work.</p><pre><code class="language-julia">using WAV
x = Signal(&quot;example.wav&quot;)</code></pre><h2 id="Signal-inspection-1"><a class="docs-heading-anchor" href="#Signal-inspection-1">Signal inspection</a><a class="docs-heading-anchor-permalink" href="#Signal-inspection-1" title="Permalink"></a></h2><p>You can examine the properties of a signal using <a href="../reference/#SignalOperators.nframes"><code>nframes</code></a>, <a href="../reference/#SignalOperators.nchannels"><code>nchannels</code></a>, <a href="../reference/#SignalOperators.framerate"><code>framerate</code></a>, and <a href="../reference/#SignalOperators.duration"><code>duration</code></a>.</p><h2 id="Signal-operators-1"><a class="docs-heading-anchor" href="#Signal-operators-1">Signal operators</a><a class="docs-heading-anchor-permalink" href="#Signal-operators-1" title="Permalink"></a></h2><p>There are several categories of signal operators: extending, cutting, filtering, ramping, and mapping.</p><h3 id="Extending-1"><a class="docs-heading-anchor" href="#Extending-1">Extending</a><a class="docs-heading-anchor-permalink" href="#Extending-1" title="Permalink"></a></h3><p>You can extend a signal using <a href="../reference/#SignalOperators.Pad"><code>Pad</code></a> or <a href="../reference/#SignalOperators.Append"><code>Append</code></a>. A padded signal becomes infinite by appending the signal by a repeated value, usually <code>one</code> or <code>zero</code>. You can append two or more signals (or <a href="../reference/#SignalOperators.Prepend"><code>Prepend</code></a>) so they occur one after another.</p><pre><code class="language-julia">Pad(x,zero) |&gt; duration |&gt; isinf == true
Append(x,y,z) |&gt; duration == duration(x) + duration(y) + duration(z)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You cannot append more than one new signal within a pipe. That is, the following will throw an error.</p><pre><code class="language-julia"># Don&#39;t do this!
x |&gt; Append(y,z)</code></pre><p>This is because <code>Append(y,z)</code> does not return a function to be piped (as <code>Append(y)</code> does). It returns a signal with <code>y</code> followed by <code>z</code>. You can instead call this as follows.</p><pre><code class="language-julia"># This will do what you want!
x |&gt; Append(y) |&gt; Append(z)</code></pre></div></div><h3 id="Cutting-1"><a class="docs-heading-anchor" href="#Cutting-1">Cutting</a><a class="docs-heading-anchor-permalink" href="#Cutting-1" title="Permalink"></a></h3><p>You can cut signals apart, removing either the end of the signal (<a href="../reference/#SignalOperators.Until"><code>Until</code></a>) or the beginning (<a href="../reference/#SignalOperators.After"><code>After</code></a>). The operations are exact compliments of one another.</p><pre><code class="language-julia">Append(Until(x,2s),After(x,2s)) |&gt; nframes == nframes(x)</code></pre><h3 id="Filtering-1"><a class="docs-heading-anchor" href="#Filtering-1">Filtering</a><a class="docs-heading-anchor-permalink" href="#Filtering-1" title="Permalink"></a></h3><p>You can filter signals, removing undesired frequencies using <a href="../reference/#SignalOperators.Filt"><code>Filt</code></a>.</p><pre><code class="language-julia">Signal(randn) |&gt; Filt(Lowpass,20Hz)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you write <code>using DSP</code> you will have to also write <code>dB = SignalOperators.Units.dB</code> if you want to make use of the proper meaning of <code>dB</code> for <code>SignalOperators</code>: <code>DSP</code> also defines <code>dB</code>.</p></div></div><p>An unusual filter is <a href="../reference/#SignalOperators.Normpower"><code>Normpower</code></a>: it computes the root mean squared power of the signal and then normalizes each frame by that value.</p><h3 id="Ramping-1"><a class="docs-heading-anchor" href="#Ramping-1">Ramping</a><a class="docs-heading-anchor-permalink" href="#Ramping-1" title="Permalink"></a></h3><p>A Ramp allows for smooth transitions between 0 amplitude and the full amplitude of the signal. It is useful to avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.</p><pre><code class="language-julia">Signal(sin,ω=2kHz) |&gt; Until(5s) |&gt; Ramp</code></pre><p>You can ramp only the start of a signal (<a href="../reference/#SignalOperators.RampOn"><code>RampOn</code></a>), or the end of it (<a href="../reference/#SignalOperators.RampOff"><code>RampOff</code></a>) and you can use ramps to create a smooth transition between two signals (<a href="../reference/#SignalOperators.FadeTo"><code>FadeTo</code></a>).</p><h3 id="General-operators-1"><a class="docs-heading-anchor" href="#General-operators-1">General operators</a><a class="docs-heading-anchor-permalink" href="#General-operators-1" title="Permalink"></a></h3><p>The most general operator is <a href="../reference/#SignalOperators.OperateOn"><code>OperateOn</code></a>. It works a lot like <code>map</code> but automatically promotes the signals, as with all operators, <em>and</em> it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest <em>finite</em>-length signal.</p><pre><code class="language-julia">a = Signal(sin,ω=2kHz) |&gt; Until(2s)
b = Signal(sin,ω=1kHz) |&gt; Until(3s)
a_minus_b = OperateOn(-,a,b)</code></pre><p>The function <a href="../reference/#SignalOperators.OperateOn"><code>OperateOn</code></a> cannot itself be piped, due to ambiguity in the arguments, but you can use the shorter <a href="../reference/#SignalOperators.Operate"><code>Operate</code></a> for these purposes.</p><pre><code class="language-julia">a_minus_b = a |&gt; Operate(-,b)</code></pre><p>A number of shortcuts for <code>OperateOn</code> exist, and these can be piped normally. There are shortcuts for addition (<a href="../reference/#SignalOperators.Mix"><code>Mix</code></a>) and multiplication (<a href="../reference/#SignalOperators.Amplify"><code>Amplify</code></a>).</p><pre><code class="language-julia">a_plus_b = a |&gt; Mix(b)
a_times_b = a |&gt; Amplify(b)</code></pre><p>There are shortcuts to add or isolate channels, <a href="../reference/#SignalOperators.AddChannel"><code>AddChannel</code></a> and <a href="../reference/#SignalOperators.SelectChannel"><code>SelectChannel</code></a>. These set the keyword argument <code>bychannel</code> of <a href="../reference/#SignalOperators.OperateOn"><code>OperateOn</code></a> to <code>false</code> (see <a href="../reference/#SignalOperators.OperateOn"><code>OperateOn</code></a>&#39;s documentation for details).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../custom_signal/">Custom Signals »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 21 January 2020 23:03">Tuesday 21 January 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
