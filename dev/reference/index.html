<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SignalOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SignalOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../manual/">Manual</a></li><li><a class="toctext" href="../custom/">Custom Signals</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Signal-Generation-1">Signal Generation</a></li><li><a class="toctext" href="#Signal-Inspection-1">Signal Inspection</a></li><li><a class="toctext" href="#Signal-Reformatting-1">Signal Reformatting</a></li><li><a class="toctext" href="#Signal-Operators-1">Signal Operators</a></li><li><a class="toctext" href="#Custom-Signals-1">Custom Signals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/SignalOperators.jl/blob/master/docs/src/reference.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><h2><a class="nav-anchor" id="Signal-Generation-1" href="#Signal-Generation-1">Signal Generation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.signal" href="#SignalOperators.signal"><code>SignalOperators.signal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">signal(x,[samplerate])</code></pre><p>Coerce <code>x</code> to be a signal, optionally specifying its sample rate (usually in Hz). All signal operators first call <code>signal(x)</code> for each argument. This means you only need to call <code>signal</code> when you want to pass additional arguments to it.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you pipe <code>signal</code> and pass a sample rate, you must specify the units of the sample rate (e.g. <code>x |&gt; signal(20Hz)</code>). A unitless number is always interpreted as a constant, infinite-length signal (see below).</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you are implementing <code>signal</code> for a <a href="../custom/#custom_signals-1">custom signal</a>, you will need to support the second argument of <code>signal</code> by specifying <code>fs::Union{Number,Missing}=missing</code>, or equivalent, as your second argument.</p></div></div><p>The type of objects that can be coerced to signals are as follows.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL134-L156">source</a><div><div><p><strong>Existing signals</strong></p><p>Any existing signal just returns itself from <code>signal</code>. If a sample rate is specified it will be set if <code>x</code> has an unknown sample rate. If it has a known sample rate and doesn&#39;t match <code>samplerate(x)</code> an error will be thrown. If you want to change the sample rate of a signal use <a href="#SignalOperators.tosamplerate"><code>tosamplerate</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL162-L171">source</a><div><div><p><strong>Numbers</strong></p><p>Numbers can be treated as infinite length, constant signals of unknown sample rate.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/numbers.jl#LL16-L23">source</a><div><div><p><strong>Arrays</strong></p><p>Arrays can be treated as signals. The first dimension is time, the second channels.</p><p><a href="https://github.com/JuliaArrays/AxisArrays.jl"><code>AxisArrays</code></a>, if they have an axis labeled <code>time</code> and one or zero additional axes, can be treated as a signal. The time dimension must be represented using on object with the <code>step</code> function defined (e.g. any <code>AbstractRange</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/arrays.jl#LL7-L18">source</a><div><div><p><strong>Functions</strong></p><pre><code class="language-none">signal(fn,[samplerate];[ω/frequency],[ϕ/phase])</code></pre><p>Functions can define infinite length signals of known or unknown sample rate. The function <code>fn</code> can either return a number or, for multi-channel signals, a tuple of values.</p><p>The input to <code>fn</code> is either a phase value or a time value. If a frequency is specified (using either the ω or frequency keyword), the input to <code>fn</code> will be a phase value in radians, ranging from 0 to 2π. If no frequency is specified the value passed to <code>fn</code> is the time in seconds. Specifying phase (by the ϕ or phase keyword) will first add that value to the input before passing it to <code>fn</code>. When frequency is specified, the phase is assumed to be in units of radians (but you can also pass degrees by using <code>°</code> or a unit of time (e.g. <code>s</code> for seconds)). When frequency is not specified the phase is assumed to be in units of seconds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/functions.jl#LL68-L87">source</a><div><div><p>If <code>fn == randn</code> no frequency or phase can be specified. Instead there is a single keyword argument, <code>rng</code>, which allows you to specify the random number generator; <code>rng</code> defaults to <code>Random.GLOBAL_RNG</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/functions.jl#LL103-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.sink" href="#SignalOperators.sink"><code>SignalOperators.sink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sink([signal],[to=AxisArray];duration,samplerate)</code></pre><p>Creates a given type of object (<code>to</code>) from a signal. By default it is an <code>AxisArray</code> with time as the rows and channels as the columns. If a filename is specified for <code>to</code>, the signal is written to the given file. If given a type (e.g. <code>Array</code>) the signal is written to a value of that type.</p><p><strong>Sample Rate</strong></p><p>The sample rate does not need to be specified, it will use either the sample rate of <code>signal</code> or a default sample rate (which raises a warning). If specified, the given sample rate is passed to <a href="#SignalOperators.signal"><code>signal</code></a> when coercing the input to a signal.</p><p><strong>Duration</strong></p><p>You can limit the output of the given signal to the specified duration. If this duration exceedes the duration of the passed signal an error will be thrown.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/sink.jl#LL2-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.sink!" href="#SignalOperators.sink!"><code>SignalOperators.sink!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sink!(array,x;[samplerate])</code></pre><p>Write <code>size(array,1)</code> samples of signal <code>x</code> to <code>array</code>. If no sample rate has been specified for <code>x</code> you can specify it now, using <code>samplerate</code> (it will default to 44.1kHz).</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/sink.jl#LL61-L68">source</a></section><h2><a class="nav-anchor" id="Signal-Inspection-1" href="#Signal-Inspection-1">Signal Inspection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.inflen" href="#SignalOperators.inflen"><code>SignalOperators.inflen</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">inflen</code></pre><p>Represents an infinite length. Proper overloads are defined to handle arithmetic and ordering for the infinite value.</p><p><strong>Missing values</strong></p><p>For the purposes of <code>SignalOperators</code> missing values are considered to be unknown, but of finite length. For example: <code>inflen * missing == inflen</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/inflen.jl#LL6-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.duration" href="#SignalOperators.duration"><code>SignalOperators.duration</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">duration(x)</code></pre><p>Return the duration of the signal in seconds, if known. May return <code>missing</code> or <a href="#SignalOperators.inflen"><code>inflen</code></a>. The value <code>missing</code> always denotes a finite but unknown length.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If your are implementing a <a href="../custom/#custom_signals-1">custom signal</a>, you need not normally define <code>duration</code> as it will be computed from <code>nsamples</code> and <code>samplerate</code>. However, if one or both of these is <code>missing</code> and you want <code>duartion</code> to return a non-missing value, you can define custom method of <code>duration</code>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL62-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.nsamples" href="#SignalOperators.nsamples"><code>SignalOperators.nsamples</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nsamples(x)</code></pre><p>Returns the number of samples in the signal, if known. May return <code>missing</code> or <a href="#SignalOperators.inflen"><code>inflen</code></a>. The value <code>missing</code> always denotes a finite but unknown length.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The return value of <code>nsamples</code> for a block (see <a href="../custom/#custom_signals-1">custom signals</a> must be a non-missing, finite value.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL79-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.nchannels" href="#SignalOperators.nchannels"><code>SignalOperators.nchannels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nchannels(x)</code></pre><p>Returns the number of channels in the signal.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL107-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.samplerate" href="#SignalOperators.samplerate"><code>SignalOperators.samplerate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">samplerate(x)</code></pre><p>Returns the sample rate of the signal (in Hertz). May return <code>missing</code> if the sample rate is unknown.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL96-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.channel_eltype" href="#SignalOperators.channel_eltype"><code>SignalOperators.channel_eltype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">channel_eltype(x)</code></pre><p>Returns the element type of an individual channel of a signal (e.g. <code>Float64</code>).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>channel_eltype</code> and <code>eltype</code> are, in most cases, the same, but not necesarilly so.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL117-L128">source</a></section><h2><a class="nav-anchor" id="Signal-Reformatting-1" href="#Signal-Reformatting-1">Signal Reformatting</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.tosamplerate" href="#SignalOperators.tosamplerate"><code>SignalOperators.tosamplerate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tosamplerate(x,fs;blocksize)</code></pre><p>Change the sample rate of <code>x</code> to the given sample rate <code>fs</code>. The underlying implementation depends on whether the input is a computed or data signal, as determined by <a href="#SignalOperators.EvalTrait"><code>EvalTrait</code></a>.</p><p>Computed signals (e.g. <code>signal(sin)</code>) are resampled exactly: the result is simply computed for more time points or fewer time points, so as to generate the appropriate number of samples.</p><p>Data-based signals (<code>signal(rand(50,2))</code>) are resampled using filtering (akin to <code>DSP.resample</code>). In this case you can use the keyword arugment <code>blocksize</code> to change the analysis window used. See <a href="#SignalOperators.filtersignal"><code>filtersignal</code></a> for more details. Setting <code>blocksize</code> for a computed signal will succeed, but different <code>blocksize</code> values have no effect on the underlying implementation.</p><p><strong>Implementation</strong></p><p>You need only implement this function for custom signals for particular scenarios, described below.</p><p><strong>Custom Computed Signals</strong></p><p>If you implement a new sigal type that is a computed signal, you must implement <code>tosamplerate</code> with the following type signature.</p><pre><code class="language-julia">
function tosamplerate(x::MyCustomSignal,s::IsSignal{&lt;:Any,&lt;:Number},
    c::ComputedSignal,samplerate;blocksize)

    ## ...
end</code></pre><p>The result should be a new version of the computed signal with the given sample rate.</p><p><strong>Handling missing sample rates</strong></p><p>If you implement a new signal type that can handle missing sample rate values, you will need to implement the following version of <code>tosamplerate</code> so that a known sample rate can be applied to a signal with a missing sample rate.</p><pre><code class="language-julia">
function tosamplerate(x::MyCustomSignal,s::IsSignal{&lt;:Any,Missing},
    evaltrait,samplerate;blocksize)

    ## ...
end</code></pre><p>The result should be a new version of the signal with the specified sample rate.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/reformatting.jl#LL4-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.tochannels" href="#SignalOperators.tochannels"><code>SignalOperators.tochannels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tochannels(x,ch)</code></pre><p>Force a signal to have <code>ch</code> number of channels, by mixing channels together or broadcasting a single channel over multiple channels.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/reformatting.jl#LL110-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.toeltype" href="#SignalOperators.toeltype"><code>SignalOperators.toeltype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">toeltype(x,T)</code></pre><p>Converts individual samples in signal <code>x</code> to type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/reformatting.jl#LL152-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.format" href="#SignalOperators.format"><code>SignalOperators.format</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">format(x,fs,ch)</code></pre><p>Efficiently convert both the samplerate (<code>fs</code>) and channels <code>ch</code> of signal <code>x</code>. This selects an optimal ordering for <code>tosamplerate</code> and <code>tochannels</code> to avoid redundant computations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/reformatting.jl#LL160-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.uniform" href="#SignalOperators.uniform"><code>SignalOperators.uniform</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">uniform(xs;channels=false)</code></pre><p>Promote the sample rate (and optionally the number of channels) to be the highest sample rate (and optionally highest channel count) of the iterable of signals <code>xs</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>uniform</code> rarely needs to be called directly. It is called implicitly on all passed signals, within the body of operators such as <a href="#SignalOperators.mapsignal"><code>mapsignal</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/reformatting.jl#LL177-L190">source</a></section><h2><a class="nav-anchor" id="Signal-Operators-1" href="#Signal-Operators-1">Signal Operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.until" href="#SignalOperators.until"><code>SignalOperators.until</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">until(x,time)</code></pre><p>Create a signal of all samples of <code>x</code> up until and including <code>time</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/cutting.jl#LL36-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.after" href="#SignalOperators.after"><code>SignalOperators.after</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">after(x,time)</code></pre><p>Create a signal of all samples of <code>x</code> after <code>time</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/cutting.jl#LL44-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.append" href="#SignalOperators.append"><code>SignalOperators.append</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">append(x,y,...)</code></pre><p>Append a series of signals, one after the other.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/appending.jl#LL17-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.prepend" href="#SignalOperators.prepend"><code>SignalOperators.prepend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">prepend(x,y,...)</code></pre><p>Prepend the series of signals: <code>prepend(xs...)</code> is equivalent to <code>append(reverse(xs)...)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/appending.jl#LL23-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.pad" href="#SignalOperators.pad"><code>SignalOperators.pad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pad(x,padding)</code></pre><p>Create a signal that appends an infinite number of values, <code>padding</code>, to <code>x</code>. The value <code>padding</code> can be:</p><ul><li>a number</li><li>a tuple or vector</li><li>a type function: a one argument function of the <code>channel_eltype</code> of <code>x</code></li><li>a value function: a one argument function of the signal <code>x</code> for which   <code>SignalOperators.valuefunction(padding) == true</code>.</li><li>an indexing function: a three argument function following the same type signature as <code>getindex</code> for two dimensional arrays.</li></ul><p>If the signal is already infinitely long (e.g. a previoulsy padded signal), <code>pad</code> has no effect.</p><p>If <code>padding</code> is a number it is used as the value for all samples and channels past the end of <code>x</code>.</p><p>If <code>padding</code> is a tuple or vector it is the value for all samples past the end of <code>x</code>.</p><p>If <code>padding</code> is a type function it is passed the <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of the signal and the resulting value is used as the value for all samples past the end of <code>x</code>. Examples include <code>zero</code> and <code>one</code></p><p>If <code>padding</code> is a value function it is passed <code>x</code> just before padding during <code>sink</code> begins and it should return a tuple of <code>channel_eltype(x)</code> values. This value is repeated for the remaining samples. It is generally only useful when x is an AbstractArray.</p><p>If <code>padding</code> is an indexing function (it accepts 3 arguments) it will be used to retrieve samples from the signal <code>x</code> assuming it conforms to the <code>AbstractArray</code> interface, with the first index being samples and the second channels. If the sample index goes past the bounds of the array, it should be transformed to an index within the range of that array. Note that such padding functions only work on signals that are also AbstractArray objects. You can always generate an array from a given signal by first passing it through <code>sink</code> or <code>sink!</code>.</p><p><strong>See also</strong></p><p><a href="#SignalOperators.cycle"><code>cycle</code></a> <a href="#SignalOperators.mirror"><code>mirror</code></a> <a href="#SignalOperators.lastsample"><code>lastsample</code></a> <a href="#SignalOperators.valuefunction"><code>valuefunction</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/padding.jl#LL18-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.mirror" href="#SignalOperators.mirror"><code>SignalOperators.mirror</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mirror(x,i,j)</code></pre><p>An indexing function which mirrors the indices when i &gt; size(x,1). This means that past the end of the signal x, the signal first repeats with samples in reverse order, then repeats in the original order, so on and so forth. It can be passed as the second argument to  <a href="#SignalOperators.pad"><code>pad</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/padding.jl#LL104-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.cycle" href="#SignalOperators.cycle"><code>SignalOperators.cycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cycle(x,i,j)</code></pre><p>An indexing function which wraps index i using mod, thus repeating the signal when i &gt; size(x,1). It can be passed as the second argument to <a href="#SignalOperators.pad"><code>pad</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/padding.jl#LL95-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.lastsample" href="#SignalOperators.lastsample"><code>SignalOperators.lastsample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lastsample</code></pre><p>When passed as an argument to <code>pad</code>, allows padding using the last sample of a signal. You cannot use this function in other contexts, and it will normally throw an error. See <a href="#SignalOperators.pad"><code>pad</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/padding.jl#LL73-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.valuefunction" href="#SignalOperators.valuefunction"><code>SignalOperators.valuefunction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SignalOperators.valuefunction(fn)</code></pre><p>Returns true if <code>fn</code> should be treated as a value function. See <a href="#SignalOperators.pad"><code>pad</code></a>. If you wish your own function to be a value function, you can do this as follows.</p><pre><code class="language-none">SignalOperators.valuefunction(::typeof(myfun)) = true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/padding.jl#LL82-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.filtersignal" href="#SignalOperators.filtersignal"><code>SignalOperators.filtersignal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">filtersignal(x,h;[blocksize])</code></pre><p>Apply the given filter <code>h</code> (from <a href="https://github.com/JuliaDSP/DSP.jl"><code>DSP</code></a>) to signal <code>x</code>.</p><p><strong>Blocksize</strong></p><p>Blocksize determines the size of the buffer used when computing intermediate values of the filter. It defaults to 4096. It need not normally be adjusted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/filters.jl#LL80-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.lowpass" href="#SignalOperators.lowpass"><code>SignalOperators.lowpass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lowpass(x,low;[order=5],[method=Butterworth(order)],[blocksize])</code></pre><p>Apply a lowpass filter to x at the given cutoff frequency (<code>low</code>). See <a href="#SignalOperators.filtersignal"><code>filtersignal</code></a> for details on <code>blocksize</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/filters.jl#LL22-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.highpass" href="#SignalOperators.highpass"><code>SignalOperators.highpass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">highpass(x,high;[order=5],[method=Butterworth(order)],[blocksize])</code></pre><p>Apply a highpass filter to x at the given cutoff frequency (<code>low</code>). See <a href="#SignalOperators.filtersignal"><code>filtersignal</code></a> for details on <code>blocksize</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/filters.jl#LL36-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.bandpass" href="#SignalOperators.bandpass"><code>SignalOperators.bandpass</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bandpass(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])</code></pre><p>Apply a bandpass filter to x at the given cutoff frequencies (<code>low</code> and <code>high</code>). See <a href="#SignalOperators.filtersignal"><code>filtersignal</code></a> for details on <code>blocksize</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/filters.jl#LL50-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.bandstop" href="#SignalOperators.bandstop"><code>SignalOperators.bandstop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bandstop(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])</code></pre><p>Apply a bandstop filter to x at the given cutoff frequencies (<code>low</code> and <code>high</code>). See <a href="#SignalOperators.filtersignal"><code>filtersignal</code></a> for details on <code>blocksize</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/filters.jl#LL65-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.normpower" href="#SignalOperators.normpower"><code>SignalOperators.normpower</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">normpower(x)</code></pre><p>Return a signal with normalized power. That is, divide all samples by the root-mean-squared value of the entire signal.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/filters.jl#LL309-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.mapsignal" href="#SignalOperators.mapsignal"><code>SignalOperators.mapsignal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapsignal(fn,arguments...;padding,bychannel)</code></pre><p>Apply <code>fn</code> across the samples of arguments, producing a signal of the output of <code>fn</code>. Shorter signals are padded to accommodate the longest finite-length signal. The function <code>fn</code> should treat each argument as a single number and return a single number. This operation is broadcast across all channels of the input. It is expected to be a type stable function.</p><p>Normally the signals are first promoted to have the same samle rate and the same number of channels using <a href="#SignalOperators.uniform"><code>uniform</code></a> (with <code>channels=true</code>).</p><p><strong>Cross-channel functions</strong></p><p>The function <code>fn</code> is normally broadcast across channels, but if you wish to treat each channel separately you can set <code>bychannel=false</code>. In this case the inputs to <code>fn</code> will be indexable objects (tuples or arrays) of all channel values for a given sample, and <code>fn</code> should return a type-stable tuple value (for a multi-channel or single-channel result) or a number (for a single-channel result only). For example, the following would swap the left and right channels.</p><pre><code class="language-julia">x = rand(10,2)
swapped = mapsignal(x,bychannel=false) do val
    val[2],val[1]
end</code></pre><p>When <code>bychannel=false</code> the channels of each signal are not promoted:</p><p><strong>Padding</strong></p><p>Padding determines how samples past the end of shorter signals are reported. The value of <code>padding</code> is passd to <a href="#SignalOperators.pad"><code>pad</code></a>. Its default value is determined by the value of <code>fn</code>. The default value for the four basic arithmetic operators is their identity (<code>one</code> for <code>*</code> and <code>zero</code> for <code>+</code>). These defaults are set on the basis of <code>fn</code> using <code>default_pad(fn)</code>. A fallback implementation of <code>default_pad</code> returns <code>zero</code>.</p><p>To define a new default for a specific function, just create a new method of <code>default_pad(fn)</code></p><pre><code class="language-julia">
myfun(x) = 2x + 3
SignalOperators.default_pad(::typeof(myfun)) = one
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/mapsignal.jl#LL63-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.mix" href="#SignalOperators.mix"><code>SignalOperators.mix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mix(xs...)</code></pre><p>Sum all signals together, using <a href="#SignalOperators.mapsignal"><code>mapsignal</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/mapsignal.jl#LL247-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.amplify" href="#SignalOperators.amplify"><code>SignalOperators.amplify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">amplify(xs...)</code></pre><p>Find the product, on a per-sample basis, for all signals <code>xs</code> using <a href="#SignalOperators.mapsignal"><code>mapsignal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/mapsignal.jl#LL258-L265">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.addchannel" href="#SignalOperators.addchannel"><code>SignalOperators.addchannel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addchannel(xs...)</code></pre><p>Concatenate the channels of all signals into one signal, using <a href="#SignalOperators.mapsignal"><code>mapsignal</code></a>. This will result in a signal with <code>sum(nchannels,xs)</code> channels.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/mapsignal.jl#LL270-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.channel" href="#SignalOperators.channel"><code>SignalOperators.channel</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">channel(x,n)</code></pre><p>Select channel <code>n</code> of signal <code>x</code>, as a single-channel signal, using <a href="#SignalOperators.mapsignal"><code>mapsignal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/mapsignal.jl#LL285-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.rampon" href="#SignalOperators.rampon"><code>SignalOperators.rampon</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rampon(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the onset of a signal, smoothly transitioning from 0 to full amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/ramps.jl#LL139-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.rampoff" href="#SignalOperators.rampoff"><code>SignalOperators.rampoff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rampoff(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the offset of a signal, smoothly transitioning from full amplitude to 0 amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/ramps.jl#LL161-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.ramp" href="#SignalOperators.ramp"><code>SignalOperators.ramp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ramp(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the onset and offset of a signal, smoothly transitioning from 0 to full amplitude over the course of <code>len</code> seconds at the start and from full to 0 amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/ramps.jl#LL183-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.fadeto" href="#SignalOperators.fadeto"><code>SignalOperators.fadeto</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fadeto(x,y,[len=10ms],[fn=x-&gt;sinpi(0.5x)])</code></pre><p>Append x to y, with a smooth transition lasting <code>len</code> seconds fading from <code>x</code> to <code>y</code> (so the total length is <code>duration(x) + duration(y) - len</code>).</p><p>This fade is accomplished with a <a href="#SignalOperators.rampoff"><code>rampoff</code></a> of <code>x</code> and a <a href="#SignalOperators.rampon"><code>rampon</code></a> for <code>y</code>. <code>fn</code> should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/ramps.jl#LL206-L221">source</a></section><h2><a class="nav-anchor" id="Custom-Signals-1" href="#Custom-Signals-1">Custom Signals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.SignalTrait" href="#SignalOperators.SignalTrait"><code>SignalOperators.SignalTrait</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SiganlOperators.SignalTrait(::Type{T}) where T</code></pre><p>Returns either <code>nothing</code> if the type T should not be considered a signal (the default) or <a href="#SignalOperators.IsSignal"><code>IsSignal</code></a> to indicate the signal format for this signal.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL22-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.IsSignal" href="#SignalOperators.IsSignal"><code>SignalOperators.IsSignal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SignalOperators.IsSignal{T,Fs,L}</code></pre><p>Represents the format of a signal type with three type parameters:</p><ul><li><code>T</code> - The <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of the signal.</li><li><code>Fs</code> - The type of the samplerate. It should be either <code>Float64</code> or   <code>Missing</code>.</li><li><code>L</code> - The type of the length of the signal. It should be either</li></ul><p><code>InfiniteLength</code>, <code>Missing</code> or <code>Int</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL7-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.EvalTrait" href="#SignalOperators.EvalTrait"><code>SignalOperators.EvalTrait</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SiganlOperators.EvalTrait(x)</code></pre><p>Indicates whether the signal is a <code>DataSignal</code> or <code>ComputedSignal</code>. Data signals represent samples concretely as a set of samples. Examples include arrays and numbers. Data signals generally return themselves, or some wrapper type when <code>sink</code> is called on them. Computed signals are any signal that invovles some intermediate computation, in which samples must be computued on the fly. Calls to <code>sink</code> on a computed signal results in some new, data signal. Most signals returned by a signal operator are computed signals.</p><p>Computed signals have the extra responsibility of implementing <a href="#SignalOperators.tosamplerate"><code>tosamplerate</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/signal.jl#LL189-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.nextblock" href="#SignalOperators.nextblock"><code>SignalOperators.nextblock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SignalOperators.nextblock(x,maxlength,skip,[block])</code></pre><p>Retrieve the next block of samples for signal <code>x</code>. The final, fourth argument is optional. If it is left out, nextblock returns the first block of the signal. The resulting block must has no more than <code>maxlength</code> samples, but may have fewer samples than that; it should not have zero samples unless <code>maxlength == 0</code>. If <code>skip == true</code>, it is guaranted that <a href="#SignalOperators.sample"><code>sample</code></a> will never be called on the returned block. The value of <code>skip</code> is <code>true</code>, for example, when skipping blocks during a call to <a href="#SignalOperators.after"><code>after</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/sink.jl#LL89-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SignalOperators.sample" href="#SignalOperators.sample"><code>SignalOperators.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SignalOperators.sample(x,block,i)</code></pre><p>Retrieves the sample at index <code>i</code> of the given block of signal <code>x</code>. A sample is one or more channels of <code>chnanle_eltypep(x)</code> values. The return value should be an indexable object (e.g. a number, tuple or array) of these channel values. This method should be implemented by blocks of <a href="../custom/#custom_signals-1">custom signals</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/c46f7b42f3710d8054669c9c07bdb5817f27463d/src/sink.jl#LL105-L115">source</a></section><footer><hr/><a class="previous" href="../custom/"><span class="direction">Previous</span><span class="title">Custom Signals</span></a></footer></article></body></html>
