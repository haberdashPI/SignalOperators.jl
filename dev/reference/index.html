<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SignalOperators.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SignalOperators.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../custom_signal/">Custom Signals</a></li><li><a class="tocitem" href="../custom_sink/">Custom Sinks</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Signal-Generation-1"><span>Signal Generation</span></a></li><li><a class="tocitem" href="#Signal-Inspection-1"><span>Signal Inspection</span></a></li><li><a class="tocitem" href="#Signal-Operators-1"><span>Signal Operators</span></a></li><li><a class="tocitem" href="#Custom-Signals-1"><span>Custom Signals</span></a></li><li><a class="tocitem" href="#Custom-Sinks-1"><span>Custom Sinks</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/haberdashPI/SignalOperators.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h1><h2 id="Signal-Generation-1"><a class="docs-heading-anchor" href="#Signal-Generation-1">Signal Generation</a><a class="docs-heading-anchor-permalink" href="#Signal-Generation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Signal" href="#SignalOperators.Signal"><code>SignalOperators.Signal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Signal(x,[framerate])</code></pre><p>Coerce <code>x</code> to be a signal, optionally specifying its frame rate (usually in Hz). All signal operators first call <code>Signal(x)</code> for each argument. This means you only need to call <code>Signal</code> when you want to pass additional arguments to it.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you pipe <code>Signal</code> and pass a frame rate, you must specify the units of the frame rate (e.g. <code>x |&gt; Signal(20Hz)</code>). A unitless number is always interpreted as a constant, infinite-length signal (see below).</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you are implementing <code>Signal</code> for a <a href="../custom_signal/#custom_signals-1">custom signal</a>, you will need to support the second argument of <code>Signal</code> by specifying <code>fs::Union{Number,Missing}=missing</code>, or equivalent.</p></div></div><p>The type of objects that can be coerced to signals are as follows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL132-L153">source</a></section><section><div><p><strong>Filenames</strong></p><p>A string with a filename ending with an appropriate filetype can be read in as a signal. You will need to call <code>import</code> or <code>using</code> on the backend for reading the file.</p><p>Available backends include the following pacakges</p><ul><li><a href="https://github.com/dancasimiro/WAV.jl">WAV</a></li><li><a href="https://github.com/JuliaAudio/LibSndFile.jl">LibSndFile</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL168-L180">source</a></section><section><div><p><strong>Existing signals</strong></p><p>Any existing signal just returns itself from <code>Signal</code>. If a frame rate is specified it will be set if <code>x</code> has an unknown frame rate. If it has a known frame rate and doesn&#39;t match <code>framerate(x)</code> an error will be thrown. If you want to change the frame rate of a signal use <a href="#SignalOperators.ToFramerate"><code>ToFramerate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL189-L198">source</a></section><section><div><p><strong>Numbers</strong></p><p>Numbers can be treated as infinite length, constant signals of unknown frame rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/numbers.jl#LL16-L23">source</a></section><section><div><p><strong>Arrays</strong></p><p>Any array can be interpreted as a signal. By default the first dimension is time, the second channels and their frame rate is a missing value. If you pass a non-missin gframerate, and the array currently has a missing frame rate a <code>Tuple</code> value will be returned (see &quot;Array &amp; Number&quot; below).</p><p>If you specify a non-missing frame rate to an array type with a missing frame rate the return value will be a Tuple (see Array &amp; Number section below). Some array types change this default behavior, as follows.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Arrays of more than two dimensions are not currently supported.</p></div></div><ul><li><a href="https://github.com/JuliaArrays/AxisArrays.jl"><code>AxisArrays</code></a>, if they have an   axis labeled <code>time</code> and one or zero additional axes, can be treated as a   signal. The time dimension must be represented using on object with the <code>step</code>   function defined (e.g. any <code>AbstractRange</code> object).</li><li><a href="https://github.com/JuliaAudio/SampledSignals.jl"><code>SampleBuf</code></a> objects are   also properly interpreted as signals, as per the conventions employed for its   package.</li><li><a href="https://github.com/rafaqz/DimensionalData.jl"><code>DimensionalArrays</code></a> can be   treated as signals if there is a <code>Time</code> dimension, which must be represented   using an object with the <code>step</code> function defined (e.g. <code>AbstractRange</code>) and   zero or one additional dimensions (treated as channels)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/arrays.jl#LL6-L34">source</a></section><section><div><p><strong>Array &amp; Number</strong></p><p>A tuple of an array and a number can be interepted as a signal. The first dimension is time, the second channels, and the number determines the frame rate (in Hertz).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/arrays.jl#LL66-L74">source</a></section><section><div><p><strong>Functions</strong></p><pre><code class="language-none">Signal(fn,[framerate];[ω/frequency],[ϕ/phase])</code></pre><p>Functions can define infinite length signals of known or unknown frame rate. The function <code>fn</code> can either return a number or, for multi-channel signals, a tuple of values.</p><p>The input to <code>fn</code> is either a phase value or a time value. If a frequency is specified (using either the ω or frequency keyword), the input to <code>fn</code> will be a phase value in radians, ranging from 0 to 2π. If no frequency is specified the value passed to <code>fn</code> is the time in seconds. Specifying phase (by the ϕ or phase keyword) will first add that value to the input before passing it to <code>fn</code>. When frequency is specified, the phase is assumed to be in units of radians (but you can also pass degrees by using <code>°</code> or a unit of time (e.g. <code>s</code> for seconds)). When frequency is not specified the phase is assumed to be in units of seconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/functions.jl#LL68-L87">source</a></section><section><div><p>If <code>fn == randn</code> no frequency or phase can be specified. Instead there is a single keyword argument, <code>rng</code>, which allows you to specify the random number generator; <code>rng</code> defaults to <code>Random.GLOBAL_RNG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/functions.jl#LL103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.sink" href="#SignalOperators.sink"><code>SignalOperators.sink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sink(signal,[to])</code></pre><p>Creates a given type of object (<code>to</code>) from a signal. By default the type of the resulting sink is determined by the type of the underlying data of the signal: e.g. if <code>x</code> is a <code>SampleBuf</code> object then <code>sink(Mix(x,2))</code> is also a <code>SampleBuf</code> object. If there is no underlying data (<code>Signal(sin) |&gt; sink</code>) then a Tuple of an array and the framerate is returned.</p><p><strong>Values for <code>to</code></strong></p><p><strong>Type</strong></p><p>If <code>to</code> is an array type (e.g. <code>Array</code>, <code>DimensionalArray</code>) the signal is written to a value of that type.</p><p>If <code>to</code> is a <code>Tuple</code> the result is an <code>Array</code> of samples and a number of indicating the sample rate in Hertz.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL2-L21">source</a></section><section><div><p><strong>Filename</strong></p><p>If <code>to</code> is a string, it is assumed to describe the name of a file to which the signal will be written. You will need to call <code>import</code> or <code>using</code> on an appropriate backend for writing to the given file type.</p><p>Available backends include the following pacakges</p><ul><li><a href="https://codecov.io/gh/haberdashPI/SignalOperators.jl/src/master/src/WAV.jl">WAV</a></li><li><a href="https://github.com/JuliaAudio/LibSndFile.jl">LibSndFile</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.sink!" href="#SignalOperators.sink!"><code>SignalOperators.sink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sink!(array,x)</code></pre><p>Write <code>size(array,1)</code> frames of signal <code>x</code> to <code>array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL100-L105">source</a></section></article><h2 id="Signal-Inspection-1"><a class="docs-heading-anchor" href="#Signal-Inspection-1">Signal Inspection</a><a class="docs-heading-anchor-permalink" href="#Signal-Inspection-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.inflen" href="#SignalOperators.inflen"><code>SignalOperators.inflen</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">inflen</code></pre><p>Represents an infinite length. Proper overloads are defined to handle arithmetic and ordering for the infinite value.</p><p><strong>Missing values</strong></p><p>For the purposes of <code>SignalOperators</code> missing values are considered to be unknown, but of finite length. For example: <code>inflen * missing == inflen</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/inflen.jl#LL6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.duration" href="#SignalOperators.duration"><code>SignalOperators.duration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">duration(x)</code></pre><p>Return the duration of the signal in seconds, if known. May return <code>missing</code> or <a href="#SignalOperators.inflen"><code>inflen</code></a>. The value <code>missing</code> always denotes a finite but unknown length.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If your are implementing a <a href="../custom_signal/#custom_signals-1">custom signal</a>, you need not normally define <code>duration</code> as it will be computed from <code>nframes</code> and <code>framerate</code>. However, if one or both of these is <code>missing</code> and you want <code>duartion</code> to return a non-missing value, you can define a custom method of <code>duration</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.nframes" href="#SignalOperators.nframes"><code>SignalOperators.nframes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nframes(x)</code></pre><p>Returns the number of frames in the signal, if known. May return <code>missing</code> or <a href="#SignalOperators.inflen"><code>inflen</code></a>. The value <code>missing</code> always denotes a finite but unknown length.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The return value of <code>nframes</code> for a block (see <a href="../custom_signal/#custom_signals-1">custom signals</a>) must be a non-missing, finite value.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.nchannels" href="#SignalOperators.nchannels"><code>SignalOperators.nchannels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nchannels(x)</code></pre><p>Returns the number of channels in the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.framerate" href="#SignalOperators.framerate"><code>SignalOperators.framerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">framerate(x)</code></pre><p>Returns the frame rate of the signal (in Hertz). May return <code>missing</code> if the frame rate is unknown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.channel_eltype" href="#SignalOperators.channel_eltype"><code>SignalOperators.channel_eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_eltype(x)</code></pre><p>Returns the element type of an individual channel of a signal (e.g. <code>Float64</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>channel_eltype</code> and <code>eltype</code> are, in most cases, the same. They are distinct so that these two can diverge when appropriate.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL115-L126">source</a></section></article><h2 id="Signal-Operators-1"><a class="docs-heading-anchor" href="#Signal-Operators-1">Signal Operators</a><a class="docs-heading-anchor-permalink" href="#Signal-Operators-1" title="Permalink"></a></h2><h3 id="Basic-Operators-1"><a class="docs-heading-anchor" href="#Basic-Operators-1">Basic Operators</a><a class="docs-heading-anchor-permalink" href="#Basic-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Until" href="#SignalOperators.Until"><code>SignalOperators.Until</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Until(x,time)</code></pre><p>Create a signal of all frames of <code>x</code> up until and including <code>time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/cutting.jl#LL36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.until" href="#SignalOperators.until"><code>SignalOperators.until</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">until(x,time)</code></pre><p>Equivalent to <code>sink(Until(x,time))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Until"><code>Until</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/cutting.jl#LL44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.After" href="#SignalOperators.After"><code>SignalOperators.After</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">After(x,time)</code></pre><p>Create a signal of all frames of <code>x</code> after <code>time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/cutting.jl#LL56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.after" href="#SignalOperators.after"><code>SignalOperators.after</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">after(x,time)</code></pre><p>Equivalent to <code>sink(After(x,time))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.After"><code>After</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/cutting.jl#LL64-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Append" href="#SignalOperators.Append"><code>SignalOperators.Append</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Append(x,y,...)</code></pre><p>Append a series of signals, one after the other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/appending.jl#LL19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.append" href="#SignalOperators.append"><code>SignalOperators.append</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">append(x,y,...)</code></pre><p>Equivalent to <code>sink(Append(x,y,...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Append"><code>Append</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/appending.jl#LL35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Prepend" href="#SignalOperators.Prepend"><code>SignalOperators.Prepend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Prepend(x,y,...)</code></pre><p>Prepend the series of signals: <code>Prepend(xs...)</code> is equivalent to <code>Append(reverse(xs)...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/appending.jl#LL25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.prepend" href="#SignalOperators.prepend"><code>SignalOperators.prepend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prepend(x,y,...)</code></pre><p>Equivalent to <code>sink(Prepend(x,y,...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Prepend"><code>Prepend</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/appending.jl#LL47-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Pad" href="#SignalOperators.Pad"><code>SignalOperators.Pad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pad(x,padding)</code></pre><p>Create a signal that appends an infinite number of values, <code>padding</code>, to <code>x</code>. The value <code>padding</code> can be:</p><ul><li>a number</li><li>a tuple or vector</li><li>a type function: a one argument function of the <code>channel_eltype</code> of <code>x</code></li><li>a value function: a one argument function of the signal <code>x</code> for which   <code>SignalOperators.valuefunction(padding) == true</code>.</li><li>an indexing function: a three argument function following the same type signature as <code>getindex</code> for two dimensional arrays.</li></ul><p>If the signal is already infinitely long (e.g. a previoulsy padded signal), <code>Pad</code> has no effect.</p><p>If <code>padding</code> is a number it is used as the value for all samples past the end of <code>x</code>.</p><p>If <code>padding</code> is a tuple or vector it is the value for all frames past the end of <code>x</code>.</p><p>If <code>padding</code> is a type function it is passed the <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of the signal and the resulting value is used as the value for all frames past the end of <code>x</code>. Examples include <code>zero</code> and <code>one</code></p><p>If <code>padding</code> is a value function it is passed the signal <code>x</code> just before padding occurs during a call to <code>sink</code>; it should return a tuple of <code>channel_eltype(x)</code> values. The return value is repeated for all remaining frames of the signal. For example, <a href="#SignalOperators.lastframe"><code>lastframe</code></a> is a value function.</p><p>If <code>padding</code> is an indexing function (it accepts 3 arguments) it will be used to retrieve frames from the signal <code>x</code> assuming it conforms to the <code>AbstractArray</code> interface, with the first index being frames and the second channels. If the frame index goes past the bounds of the array, it should be transformed to an index within the range of that array. Note that such padding functions only work on signals that are also AbstractArray objects. You can always generate an array from a given signal by first passing it through <code>sink</code> or <code>sink!</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>A indexing function will also work on a signal represented as a tuple of an array and number; it simply passed the array (leaving off the number).</p></div></div><p><strong>See also</strong></p><p><a href="#SignalOperators.cycle"><code>cycle</code></a> <a href="#SignalOperators.mirror"><code>mirror</code></a> <a href="#SignalOperators.lastframe"><code>lastframe</code></a> <a href="#SignalOperators.valuefunction"><code>valuefunction</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/padding.jl#LL18-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.mirror" href="#SignalOperators.mirror"><code>SignalOperators.mirror</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mirror(x,i,j)</code></pre><p>An indexing function which mirrors the indices when i &gt; size(x,1). This means that past the end of the signal x, the signal first repeats with frames in reverse order, then repeats in the original order, so on and so forth. It can be passed as the second argument to  <a href="#SignalOperators.Pad"><code>Pad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/padding.jl#LL109-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.cycle" href="#SignalOperators.cycle"><code>SignalOperators.cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cycle(x,i,j)</code></pre><p>An indexing function which wraps index i using mod, thus repeating the signal when i &gt; size(x,1). It can be passed as the second argument to <a href="#SignalOperators.Pad"><code>Pad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/padding.jl#LL100-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.lastframe" href="#SignalOperators.lastframe"><code>SignalOperators.lastframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lastframe</code></pre><p>When passed as an argument to <code>Pad</code>, allows padding using the last frame of a signal. You cannot use this function in other contexts, and it will normally throw an error. See <a href="#SignalOperators.Pad"><code>Pad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/padding.jl#LL78-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.valuefunction" href="#SignalOperators.valuefunction"><code>SignalOperators.valuefunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.valuefunction(fn)</code></pre><p>Returns true if <code>fn</code> should be treated as a value function. See <a href="#SignalOperators.Pad"><code>Pad</code></a>. If you wish your own function to be a value function, you can do this as follows.</p><pre><code class="language-none">SignalOperators.valuefunction(::typeof(myfun)) = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/padding.jl#LL87-L96">source</a></section></article><h3 id="Mapping-Operators-1"><a class="docs-heading-anchor" href="#Mapping-Operators-1">Mapping Operators</a><a class="docs-heading-anchor-permalink" href="#Mapping-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Filt" href="#SignalOperators.Filt"><code>SignalOperators.Filt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Filt(x,::Type{&lt;:FilterType},bounds...;method=Butterworth(order),order=5,
     blocksize=4096)</code></pre><p>Apply the given filter type (e.g. <code>Lowpass</code>) using the given method to design the filter coefficients. The type is specified as per the types from <a href="https://github.com/JuliaDSP/DSP.jl"><code>DSP</code></a></p><pre><code class="language-none">Filt(x,h;[blocksize=4096])</code></pre><p>Apply the given digital filter <code>h</code> (from <a href="https://github.com/JuliaDSP/DSP.jl"><code>DSP</code></a>) to signal <code>x</code>.</p><p><strong>Blocksize</strong></p><p>Blocksize determines the size of the buffer used when computing intermediate values of the filter. It need not normally be adjusted, though changing it can alter how efficient filter application is.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The non-lazy version of <code>Filt</code> is <code>filt</code> from the <a href="https://github.com/JuliaDSP/DSP.jl"><code>DSP</code></a> package. Proper methods have been defined such that it should be possible to call <code>filt</code> on a signal and get a signal back.</p><p>The argument order for <code>filt</code> follows a different convention, with <code>x</code> coming after the filter specification. In contrast, <code>Filt</code> uses the convention of keeping <code>x</code> as the first argument to make piping possible.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/filters.jl#LL22-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Normpower" href="#SignalOperators.Normpower"><code>SignalOperators.Normpower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Normpower(x)</code></pre><p>Return a signal with normalized power. That is, divide all frames by the root-mean-squared value of the entire signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/filters.jl#LL300-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.normpower" href="#SignalOperators.normpower"><code>SignalOperators.normpower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normpower(x)</code></pre><p>Equivalent to <code>sink(Normpwoer(x))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Normpower"><code>Normpower</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/filters.jl#LL313-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.OperateOn" href="#SignalOperators.OperateOn"><code>SignalOperators.OperateOn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OperateOn(fn,arguments...;padding,bychannel)</code></pre><p>Apply <code>fn</code> across the samples of the passed signals. Shorter signals are padded to accommodate the longest finite-length signal.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is no piped version of <code>OperateOn</code>, use <a href="#SignalOperators.Operate"><code>Operate</code></a> instead. The shorter name is used for what is intended as the more common use case (piping).</p></div></div><p><strong>Channel-by-channel functions</strong></p><p>When <code>bychannel == false</code> the function <code>fn</code> should treat each of its arguments as a single number and return a single number. This operation is broadcast across all channels of the input. It is expected to be a type stable function.</p><p>The signals are first promoted to have the same sample rate and the same number of channels using <a href="#SignalOperators.Uniform"><code>Uniform</code></a>.</p><p><strong>Cross-channel functions</strong></p><p>When <code>bychannel=false</code>, rather than being applied to each channel seperately the function <code>fn</code> is applied to each frame, containing all channels. For example, for a two channel signal, the following would swap these two channels.</p><pre><code class="language-julia">x = rand(10,2)
swapped = OperateOn(x,bychannel=false) do val
    val[2],val[1]
end</code></pre><p>The signals are first promoted to have the same sample rate, but the number of channels of each input signal remains unchanged.</p><p><strong>Padding</strong></p><p>Padding determines how frames past the end of shorter signals are reported. The value of <code>padding</code> is given as the second argument to <a href="#SignalOperators.Pad"><code>Pad</code></a> these shorter signals. Its default value is determined by the value of <code>fn</code>. The default value for the four basic arithmetic operators is their identity (<code>one</code> for <code>*</code> and <code>zero</code> for <code>+</code>). These defaults are set on the basis of <code>fn</code> using <code>default_pad(fn)</code>. A fallback implementation of <code>default_pad</code> returns <code>zero</code>.</p><p>To define a new default for a specific function, just create a new method of <code>default_pad(fn)</code></p><pre><code class="language-julia">myfun(x,y) = x + 2y
SignalOperators.default_pad(::typeof(myfun)) = zero

sink(Operate(myfun,Until(1,2frames),Until(2,4frames))) == [5,5,4,4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL67-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Operate" href="#SignalOperators.Operate"><code>SignalOperators.Operate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Operate(fn,rest...;padding,bychannel)</code></pre><p>Equivalent to</p><p><code>julia (x) -&gt; OperateOn(fn,x,rest...;padding=padding,bychannel=bychannel)</code>`</p><p><strong>See also</strong></p><p><a href="#SignalOperators.OperateOn"><code>OperateOn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL148-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.operate" href="#SignalOperators.operate"><code>SignalOperators.operate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate(fn,args...;padding,bychannel)</code></pre><p>Equivalent to <code>sink(OperateOn(fn,args...;padding,bychannel))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.OperateOn"><code>OperateOn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Mix" href="#SignalOperators.Mix"><code>SignalOperators.Mix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Mix(xs...)</code></pre><p>Sum all signals together, using <a href="#SignalOperators.OperateOn"><code>OperateOn</code></a>. Unlike <code>OperateOn</code>, <code>Amplify</code> includes a piped version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL290-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.mix" href="#SignalOperators.mix"><code>SignalOperators.mix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mix(xs...)</code></pre><p>Equivalent to <code>sink(Mix(xs...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Mix"><code>Mix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL303-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Amplify" href="#SignalOperators.Amplify"><code>SignalOperators.Amplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Amplify(xs...)</code></pre><p>Find the product, on a per-frame basis, for all signals <code>xs</code> using <a href="#SignalOperators.OperateOn"><code>OperateOn</code></a>. Unlike <code>OperateOn</code>, <code>Amplify</code> includes a piped version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL315-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.amplify" href="#SignalOperators.amplify"><code>SignalOperators.amplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">amplify(xs...)</code></pre><p>Equivalent to <code>sink(Amplify(xs...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Amplify"><code>Amplify</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL328-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.AddChannel" href="#SignalOperators.AddChannel"><code>SignalOperators.AddChannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AddChannel(xs...)</code></pre><p>Concatenate the channels of all signals into one signal, using <a href="#SignalOperators.OperateOn"><code>OperateOn</code></a>. This will result in a signal with <code>sum(nchannels,xs)</code> channels. Unlike <code>OperateOn</code>, <code>AddChannels</code> includes a piped version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL340-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.addchannel" href="#SignalOperators.addchannel"><code>SignalOperators.addchannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addchannel(xs...)</code></pre><p>Equivalent to <code>sink(AddChannel(xs...))</code>.</p><p><strong>See also</strong></p><p><a href="#SignalOperators.AddChannel"><code>AddChannel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL357-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.SelectChannel" href="#SignalOperators.SelectChannel"><code>SignalOperators.SelectChannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SelectChannel(x,n)</code></pre><p>Select channel <code>n</code> of signal <code>x</code>, as a single-channel signal, using <a href="#SignalOperators.OperateOn"><code>OperateOn</code></a>. Unlike <code>OperateOn</code>, <code>SelectChannel</code> includes a piped version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL370-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.selectchannel" href="#SignalOperators.selectchannel"><code>SignalOperators.selectchannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">selectchannel(xs...)</code></pre><p>Equivalent to <code>sink(SelectChannel(xs...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.SelectChannel"><code>SelectChannel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/mapsignal.jl#LL386-L395">source</a></section></article><h3 id="Ramping-Operators-1"><a class="docs-heading-anchor" href="#Ramping-Operators-1">Ramping Operators</a><a class="docs-heading-anchor-permalink" href="#Ramping-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.RampOn" href="#SignalOperators.RampOn"><code>SignalOperators.RampOn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RampOn(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the onset of a signal, smoothly transitioning from 0 to full amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the Ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL139-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.rampon" href="#SignalOperators.rampon"><code>SignalOperators.rampon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rampon(x,[len],[fn])</code></pre><p>Equivalent to <code>sink(RampOn(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.RampOn"><code>RampOn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL161-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.RampOff" href="#SignalOperators.RampOff"><code>SignalOperators.RampOff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RampOff(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the offset of a signal, smoothly transitioning from full amplitude to 0 amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the Ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL174-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.rampoff" href="#SignalOperators.rampoff"><code>SignalOperators.rampoff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rampoff(x,[len],[fn])</code></pre><p>Equivalent to <code>sink(RampOff(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.RampOff"><code>RampOff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL196-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Ramp" href="#SignalOperators.Ramp"><code>SignalOperators.Ramp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Ramp(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the onset and offset of a signal, smoothly transitioning from 0 to full amplitude over the course of <code>len</code> seconds at the start and from full to 0 amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the Ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL208-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ramp" href="#SignalOperators.ramp"><code>SignalOperators.ramp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ramp(x,[len],[fn])</code></pre><p>Equivalent to <code>sink(Ramp(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Ramp"><code>Ramp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL231-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.FadeTo" href="#SignalOperators.FadeTo"><code>SignalOperators.FadeTo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">FadeTo(x,y,[len=10ms],[fn=x-&gt;sinpi(0.5x)])</code></pre><p>Append x to y, with a smooth transition lasting <code>len</code> seconds fading from <code>x</code> to <code>y</code> (so the total length is <code>duration(x) + duration(y) - len</code>).</p><p>This fade is accomplished with a <a href="#SignalOperators.RampOff"><code>RampOff</code></a> of <code>x</code> and a <a href="#SignalOperators.RampOn"><code>RampOn</code></a> for <code>y</code>. <code>fn</code> should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL243-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.fadeto" href="#SignalOperators.fadeto"><code>SignalOperators.fadeto</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fadeto(x,y,[len],[fn])</code></pre><p>Equivalent to <code>sink(FadeTo(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.FadeTo"><code>FadeTo</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/ramps.jl#LL273-L282">source</a></section></article><h3 id="Reformatting-Operators-1"><a class="docs-heading-anchor" href="#Reformatting-Operators-1">Reformatting Operators</a><a class="docs-heading-anchor-permalink" href="#Reformatting-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ToFramerate" href="#SignalOperators.ToFramerate"><code>SignalOperators.ToFramerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ToFramerate(x,fs;blocksize)</code></pre><p>Change the frame rate of <code>x</code> to the given frame rate <code>fs</code>. The underlying implementation depends on whether the input is a computed or data signal, as determined by <a href="#SignalOperators.EvalTrait"><code>EvalTrait</code></a>.</p><p>Computed signals (e.g. <code>Signal(sin)</code>) are resampled exactly: the result is simply computed for more time points or fewer time points, so as to generate the appropriate number of frames.</p><p>Data-based signals (<code>Signal(rand(50,2))</code>) are resampled using filtering (akin to <code>DSP.resample</code>). In this case you can use the keyword arugment <code>blocksize</code> to change the analysis window used. See <a href="#SignalOperators.Filt"><code>Filt</code></a> for more details. Setting <code>blocksize</code> for a computed signal will succeed, but different <code>blocksize</code> values have no effect on the underlying implementation.</p><p><strong>Implementation</strong></p><p>You need only implement this function for <a href="../custom_signal/#custom_signals-1">custom signals</a> for particular scenarios, described below.</p><p><strong>Custom Computed Signals</strong></p><p>If you implement a new sigal type that is a computed signal, you must implement <code>ToFramerate</code> with the following type signature.</p><pre><code class="language-julia">
function ToFramerate(x::MyCustomSignal,s::IsSignal{&lt;:Any,&lt;:Number},
    c::ComputedSignal,framerate;blocksize)

    ## ...
end</code></pre><p>The result should be a new version of the computed signal with the given frame rate.</p><p><strong>Handling missing frame rates</strong></p><p>If you implement a new signal type that can handle missing frame rate values, you will need to implement the following version of <code>ToFramerate</code> so that a known frame rate can be applied to a signal with a missing frame rate.</p><pre><code class="language-julia">
function ToFramerate(x::MyCustomSignal,s::IsSignal{&lt;:Any,Missing},
    evaltrait,framerate;blocksize)

    ## ...
end</code></pre><p>The result should be a new version of the signal with the specified frame rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL5-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.toframerate" href="#SignalOperators.toframerate"><code>SignalOperators.toframerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">toframerate(x,fs;blocksize)</code></pre><p>Equivalent to <code>sink(ToFramerate(x,fs;blocksize=blocksize))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.ToFramerate"><code>ToFramerate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL72-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ToChannels" href="#SignalOperators.ToChannels"><code>SignalOperators.ToChannels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ToChannels(x,ch)</code></pre><p>Force a signal to have <code>ch</code> number of channels, by mixing channels together or broadcasting a single channel over multiple channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL124-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.tochannels" href="#SignalOperators.tochannels"><code>SignalOperators.tochannels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tochannels(x,ch)</code></pre><p>Equivalent to <code>sink(ToChannels(x,ch))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.ToFramerate"><code>ToFramerate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL136-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ToEltype" href="#SignalOperators.ToEltype"><code>SignalOperators.ToEltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ToEltype(x,T)</code></pre><p>Converts individual samples in signal <code>x</code> to type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.toeltype" href="#SignalOperators.toeltype"><code>SignalOperators.toeltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">toeltype(x,T)</code></pre><p>Equivalent to <code>sink(ToEltype(x,T))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.ToEltype"><code>ToEltype</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL186-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Format" href="#SignalOperators.Format"><code>SignalOperators.Format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Format(x,fs,ch)</code></pre><p>Efficiently convert both the framerate (<code>fs</code>) and channels <code>ch</code> of signal <code>x</code>. This selects an optimal ordering for <code>ToFramerate</code> and <code>ToChannels</code> to avoid redundant computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL198-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.format" href="#SignalOperators.format"><code>SignalOperators.format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">format(x,fs,ch)</code></pre><p>Equivalent to <code>sink(Format(x,fs,ch))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Format"><code>Format</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL215-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Uniform" href="#SignalOperators.Uniform"><code>SignalOperators.Uniform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Uniform(xs;channels=false)</code></pre><p>Promote the frame rate (and optionally the number of channels) to be the highest frame rate (and optionally highest channel count) of the iterable of signals <code>xs</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Uniform</code> rarely needs to be called directly. It is called implicitly on all passed signals, within the body of operators such as <a href="#SignalOperators.OperateOn"><code>OperateOn</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/reformatting.jl#LL227-L240">source</a></section></article><h2 id="Custom-Signals-1"><a class="docs-heading-anchor" href="#Custom-Signals-1">Custom Signals</a><a class="docs-heading-anchor-permalink" href="#Custom-Signals-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.SignalTrait" href="#SignalOperators.SignalTrait"><code>SignalOperators.SignalTrait</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SiganlOperators.SignalTrait(::Type{T}) where T</code></pre><p>Returns either <code>nothing</code> if the type T should not be considered a signal (the default) or <a href="#SignalOperators.IsSignal"><code>IsSignal</code></a> to indicate the signal format for this signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.IsSignal" href="#SignalOperators.IsSignal"><code>SignalOperators.IsSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SignalOperators.IsSignal{T,Fs,L}</code></pre><p>Represents the Format of a signal type with three type parameters:</p><ul><li><code>T</code> - The <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of the signal.</li><li><code>Fs</code> - The type of the framerate. It should be either <code>Float64</code> or   <code>Missing</code>.</li><li><code>L</code> - The type of the length of the signal. It should be either   <code>InfiniteLength</code>, <code>Missing</code> or <code>Int</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.EvalTrait" href="#SignalOperators.EvalTrait"><code>SignalOperators.EvalTrait</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SiganlOperators.EvalTrait(x)</code></pre><p>Indicates whether the signal is a <code>DataSignal</code> or <code>ComputedSignal</code>. Data signals represent frames concretely as a set of frames. Examples include arrays and numbers. Data signals generally return themselves, or some wrapper type when <code>sink</code> is called on them. Computed signals are any signal that invovles some intermediate computation, in which frames must be computued on the fly. Calls to <code>sink</code> on a computed signal results in some new, data signal. Most signals returned by a signal operator are computed signals.</p><p>Computed signals have the extra responsibility of implementing <a href="#SignalOperators.ToFramerate"><code>ToFramerate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/signal.jl#LL216-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.nextblock" href="#SignalOperators.nextblock"><code>SignalOperators.nextblock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.nextblock(x,maxlength,skip,[last_block])</code></pre><p>Retrieve the next block of frames for signal <code>x</code>, or nothing, if no more blocks exist. Analogous to <code>Base.iterate</code>. The returned block must satisfy the interface for signal blocks as described in <a href="../custom_signal/#custom_signals-1">custom signals</a>.</p><p><strong>Arugments</strong></p><ul><li><code>x</code>: the signal to retriev blocks from</li><li><code>maxlength</code>: The resulting block must have no more than <code>maxlength</code> frames,   but may have fewer frames than that; it should not have zero frames unless   <code>maxlength == 0</code>.</li><li><code>skip</code>: If <code>skip == true</code>, it is guaranted that <a href="#SignalOperators.frame"><code>frame</code></a>   will never be called on the returned block. The value of <code>skip</code> is <code>true</code>   when skipping blocks during a call to <a href="#SignalOperators.After"><code>After</code></a>).</li><li><code>last_block</code> The fourth argument is optional. If included, the block that   occurs after this block is returned. If it is left out, nextblock returns the   very first block of the signal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.frame" href="#SignalOperators.frame"><code>SignalOperators.frame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.frame(x,block,i)</code></pre><p>Retrieves the frame at index <code>i</code> of the given block of signal <code>x</code>. A frame is one or more channels of <code>channel_eltype(x)</code> values. The return value should be an indexable object (e.g. a number, tuple or array) of these channel values. This method should be implemented by blocks of <a href="../custom_signal/#custom_signals-1">custom signals</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL162-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.timeslice" href="#SignalOperators.timeslice"><code>SignalOperators.timeslice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.timeslice(x::AbstractArray,indices)</code></pre><p>Extract the slice of x with the given time indices.</p><p><a href="../custom_signal/#custom_signals-1">Custom signals</a> can implement this method if the signal is an <code>AbstractArray</code> allowing the use of a fallback implementation of <a href="#SignalOperators.nextblock"><code>SignalOperators.nextblock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL148-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ArrayBlock" href="#SignalOperators.ArrayBlock"><code>SignalOperators.ArrayBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArrayBlock{A,S}(data::A,state::S)</code></pre><p>A straightforward implementation of blocks as an array and a custom state. The array allows a generic implementation of <a href="#SignalOperators.nframes"><code>nframes</code></a> and <a href="#SignalOperators.frame"><code>SignalOperators.frame</code></a>. The fields of this struct are <code>data</code> and <code>state</code>.</p><p><a href="../custom_signal/#custom_signals-1">Custom signals</a> can return an <code>ArrayBlock</code> from <a href="#SignalOperators.nextblock"><code>SignalOperators.nextblock</code></a> to allow for fallback implementations of <a href="#SignalOperators.nframes"><code>nframes</code></a> and <a href="#SignalOperators.frame"><code>SignalOperators.frame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/arrays.jl#LL103-L115">source</a></section></article><h2 id="Custom-Sinks-1"><a class="docs-heading-anchor" href="#Custom-Sinks-1">Custom Sinks</a><a class="docs-heading-anchor-permalink" href="#Custom-Sinks-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.initsink" href="#SignalOperators.initsink"><code>SignalOperators.initsink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.initsink(x,::Type{T},len)</code></pre><p>Initialize an object of type T so that it can store the first <code>len</code> frames of signal <code>x</code>.</p><p>If you wish an object to serve as a <a href="../custom_sink/#custom_sinks-1">custom sink</a> you can implement this method. You should probably use <a href="#SignalOperators.nchannels"><code>nchannels</code></a> and <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of <code>x</code> to determine how to initialize the object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL59-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.sink_helper!" href="#SignalOperators.sink_helper!"><code>SignalOperators.sink_helper!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.sink_helper!(result,written,x,block)</code></pre><p>Write the given <code>block</code> of frames from signal <code>x</code> to <code>result</code> given that a total of <code>written</code> frames have already been written to the result.</p><p>This method should be fast: i.e. a for loop using @simd and @inbounds. It should call <a href="#SignalOperators.nframes"><code>nframes</code></a> and <a href="#SignalOperators.frame"><code>SignalOperators.frame</code></a> on the block to write the frames. <strong>Do not call <code>frame</code> more than once for each index of the block</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/7618cc07f2f788b8779dba449692164a6de13f55/src/sink.jl#LL196-L208">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_sink/">« Custom Sinks</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 January 2020 06:55">Monday 6 January 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
