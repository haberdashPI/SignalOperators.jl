<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SignalOperators.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SignalOperators.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../custom_signal/">Custom Signals</a></li><li><a class="tocitem" href="../custom_sink/">Custom Sinks</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Signal-Generation-1"><span>Signal Generation</span></a></li><li><a class="tocitem" href="#Signal-Inspection-1"><span>Signal Inspection</span></a></li><li><a class="tocitem" href="#Signal-Operators-1"><span>Signal Operators</span></a></li><li><a class="tocitem" href="#Custom-Signals-1"><span>Custom Signals</span></a></li><li><a class="tocitem" href="#Custom-Sinks-1"><span>Custom Sinks</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/haberdashPI/SignalOperators.jl/blob/master/docs/src/reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h1><h2 id="Signal-Generation-1"><a class="docs-heading-anchor" href="#Signal-Generation-1">Signal Generation</a><a class="docs-heading-anchor-permalink" href="#Signal-Generation-1" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>signal</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.sink" href="#SignalOperators.sink"><code>SignalOperators.sink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sink([signal],[to];duration,framerate)</code></pre><p>Creates a given type of object (<code>to</code>) from a signal. By default the type of the resulting sink is determined by the type of the underlying data of the signal: e.g. if <code>x</code> is a <code>SampleBuf</code> object then <code>sink(Mix(x,2))</code> is also a <code>SampleBuf</code> object. If there is no underlying data (<code>Signal(sin) |&gt; sink</code>) then a Tuple of an array and the framerate is returned.</p><p><strong>Keyword arguments</strong></p><p><strong>Frame Rate</strong></p><p>The frame rate does not need to be specified, it will use either the frame rate of <code>Signal</code> or a default frame rate (which raises a warning). If specified, the given frame rate is passed to <a href="@ref"><code>Signal</code></a> when coercing the input to a signal.</p><p><strong>Duration</strong></p><p>You can limit the output of the given signal to the specified duration. If this duration exceedes the duration of the passed signal an error will be thrown.</p><p><strong>Values for <code>to</code></strong></p><p><strong>Type</strong></p><p>If <code>to</code> is a type (e.g. <code>Array</code>) the signal is written to a value of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL2-L33">source</a></section><section><div><p><strong>Filename</strong></p><p>If <code>to</code> is a string, it is assumed to describe the name of a file to which the signal will be written. You will need to call <code>import</code> or <code>using</code> on an appropriate backend for writing to the given file type.</p><p>Available backends include the following pacakges</p><ul><li><a href="https://codecov.io/gh/haberdashPI/SignalOperators.jl/src/master/src/WAV.jl">WAV</a></li><li><a href="https://github.com/JuliaAudio/LibSndFile.jl">LibSndFile</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL110-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.sink!" href="#SignalOperators.sink!"><code>SignalOperators.sink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sink!(array,x;[framerate])</code></pre><p>Write <code>size(array,1)</code> frames of signal <code>x</code> to <code>array</code>. If no frame rate has been specified for <code>x</code> you can specify it now, using <code>framerate</code> (it will default to 44.1kHz).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL133-L140">source</a></section></article><h2 id="Signal-Inspection-1"><a class="docs-heading-anchor" href="#Signal-Inspection-1">Signal Inspection</a><a class="docs-heading-anchor-permalink" href="#Signal-Inspection-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.inflen" href="#SignalOperators.inflen"><code>SignalOperators.inflen</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">inflen</code></pre><p>Represents an infinite length. Proper overloads are defined to handle arithmetic and ordering for the infinite value.</p><p><strong>Missing values</strong></p><p>For the purposes of <code>SignalOperators</code> missing values are considered to be unknown, but of finite length. For example: <code>inflen * missing == inflen</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/inflen.jl#LL6-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.duration" href="#SignalOperators.duration"><code>SignalOperators.duration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">duration(x)</code></pre><p>Return the duration of the signal in seconds, if known. May return <code>missing</code> or <a href="#SignalOperators.inflen"><code>inflen</code></a>. The value <code>missing</code> always denotes a finite but unknown length.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If your are implementing a <a href="../custom_signal/#custom_signals-1">custom signal</a>, you need not normally define <code>duration</code> as it will be computed from <code>nframes</code> and <code>framerate</code>. However, if one or both of these is <code>missing</code> and you want <code>duartion</code> to return a non-missing value, you can define custom method of <code>duration</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.nframes" href="#SignalOperators.nframes"><code>SignalOperators.nframes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nframes(x)</code></pre><p>Returns the number of frames in the signal, if known. May return <code>missing</code> or <a href="#SignalOperators.inflen"><code>inflen</code></a>. The value <code>missing</code> always denotes a finite but unknown length.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The return value of <code>nframes</code> for a block (see <a href="../custom_signal/#custom_signals-1">custom signals</a> must be a non-missing, finite value.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.nchannels" href="#SignalOperators.nchannels"><code>SignalOperators.nchannels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nchannels(x)</code></pre><p>Returns the number of channels in the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.framerate" href="#SignalOperators.framerate"><code>SignalOperators.framerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">framerate(x)</code></pre><p>Returns the frame rate of the signal (in Hertz). May return <code>missing</code> if the frame rate is unknown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.channel_eltype" href="#SignalOperators.channel_eltype"><code>SignalOperators.channel_eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">channel_eltype(x)</code></pre><p>Returns the element type of an individual channel of a signal (e.g. <code>Float64</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>channel_eltype</code> and <code>eltype</code> are, in most cases, the same, but not necesarilly so.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL115-L126">source</a></section></article><h2 id="Signal-Operators-1"><a class="docs-heading-anchor" href="#Signal-Operators-1">Signal Operators</a><a class="docs-heading-anchor-permalink" href="#Signal-Operators-1" title="Permalink"></a></h2><h3 id="Basic-Operators-1"><a class="docs-heading-anchor" href="#Basic-Operators-1">Basic Operators</a><a class="docs-heading-anchor-permalink" href="#Basic-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Until" href="#SignalOperators.Until"><code>SignalOperators.Until</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Until(x,time)</code></pre><p>Create a signal of all frames of <code>x</code> up Until and including <code>time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/cutting.jl#LL36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.until" href="#SignalOperators.until"><code>SignalOperators.until</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">until(x,time)</code></pre><p>Equivalent to <code>sink(Until(x,time))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Until"><code>Until</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/cutting.jl#LL44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.After" href="#SignalOperators.After"><code>SignalOperators.After</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">After(x,time)</code></pre><p>Create a signal of all frames of <code>x</code> After <code>time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/cutting.jl#LL56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.after" href="#SignalOperators.after"><code>SignalOperators.after</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">after(x,time)</code></pre><p>Equivalent to <code>sink(After(x,time))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.After"><code>After</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/cutting.jl#LL64-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Append" href="#SignalOperators.Append"><code>SignalOperators.Append</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Append(x,y,...)</code></pre><p>Append a series of signals, one after the other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/appending.jl#LL19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.append" href="#SignalOperators.append"><code>SignalOperators.append</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">append(x,y,...)</code></pre><p>Equivalent to <code>sink(Append(x,y,...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Append"><code>Append</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/appending.jl#LL35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Prepend" href="#SignalOperators.Prepend"><code>SignalOperators.Prepend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Prepend(x,y,...)</code></pre><p>Prepend the series of signals: <code>Prepend(xs...)</code> is equivalent to <code>Append(reverse(xs)...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/appending.jl#LL25-L31">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>preprend</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Pad" href="#SignalOperators.Pad"><code>SignalOperators.Pad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pad(x,padding)</code></pre><p>Create a signal that appends an infinite number of values, <code>padding</code>, to <code>x</code>. The value <code>padding</code> can be:</p><ul><li>a number</li><li>a tuple or vector</li><li>a type function: a one argument function of the <code>channel_eltype</code> of <code>x</code></li><li>a value function: a one argument function of the signal <code>x</code> for which   <code>SignalOperators.valuefunction(padding) == true</code>.</li><li>an indexing function: a three argument function following the same type signature as <code>getindex</code> for two dimensional arrays.</li></ul><p>If the signal is already infinitely long (e.g. a previoulsy padded signal), <code>Pad</code> has no effect.</p><p>If <code>padding</code> is a number it is used as the value for all frames and channels past the end of <code>x</code>.</p><p>If <code>padding</code> is a tuple or vector it is the value for all frames past the end of <code>x</code>.</p><p>If <code>padding</code> is a type function it is passed the <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of the signal and the resulting value is used as the value for all frames past the end of <code>x</code>. Examples include <code>zero</code> and <code>one</code></p><p>If <code>padding</code> is a value function it is passed <code>x</code> just before padding during <code>sink</code> begins and it should return a tuple of <code>channel_eltype(x)</code> values. This value is repeated for the remaining frames. It is generally only useful when x is an AbstractArray.</p><p>If <code>padding</code> is an indexing function (it accepts 3 arguments) it will be used to retrieve frames from the signal <code>x</code> assuming it conforms to the <code>AbstractArray</code> interface, with the first index being frames and the second channels. If the frame index goes past the bounds of the array, it should be transformed to an index within the range of that array. Note that such padding functions only work on signals that are also AbstractArray objects. You can always generate an array from a given signal by first passing it through <code>sink</code> or <code>sink!</code>.</p><p><strong>See also</strong></p><p><a href="#SignalOperators.cycle"><code>cycle</code></a> <a href="#SignalOperators.mirror"><code>mirror</code></a> <a href="#SignalOperators.lastframe"><code>lastframe</code></a> <a href="#SignalOperators.valuefunction"><code>valuefunction</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/padding.jl#LL18-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.mirror" href="#SignalOperators.mirror"><code>SignalOperators.mirror</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mirror(x,i,j)</code></pre><p>An indexing function which mirrors the indices when i &gt; size(x,1). This means that past the end of the signal x, the signal first repeats with frames in reverse order, then repeats in the original order, so on and so forth. It can be passed as the second argument to  <a href="#SignalOperators.Pad"><code>Pad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/padding.jl#LL104-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.cycle" href="#SignalOperators.cycle"><code>SignalOperators.cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cycle(x,i,j)</code></pre><p>An indexing function which wraps index i using mod, thus repeating the signal when i &gt; size(x,1). It can be passed as the second argument to <a href="#SignalOperators.Pad"><code>Pad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/padding.jl#LL95-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.lastframe" href="#SignalOperators.lastframe"><code>SignalOperators.lastframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lastframe</code></pre><p>When passed as an argument to <code>Pad</code>, allows padding using the last frame of a signal. You cannot use this function in other contexts, and it will normally throw an error. See <a href="#SignalOperators.Pad"><code>Pad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/padding.jl#LL73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.valuefunction" href="#SignalOperators.valuefunction"><code>SignalOperators.valuefunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.valuefunction(fn)</code></pre><p>Returns true if <code>fn</code> should be treated as a value function. See <a href="#SignalOperators.Pad"><code>Pad</code></a>. If you wish your own function to be a value function, you can do this as follows.</p><pre><code class="language-none">SignalOperators.valuefunction(::typeof(myfun)) = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/padding.jl#LL82-L91">source</a></section></article><h3 id="Mapping-Operators-1"><a class="docs-heading-anchor" href="#Mapping-Operators-1">Mapping Operators</a><a class="docs-heading-anchor-permalink" href="#Mapping-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Filt" href="#SignalOperators.Filt"><code>SignalOperators.Filt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Filt(x,::Type{&lt;:FilterType},bounds...;method=Butterworth(order),order=5,
     blocksize=4096)</code></pre><p>Apply the given filter type (e.g. <code>Lowpass</code>) using the given method to design the filter coefficients. The type is specified as per the types from <a href="https://github.com/JuliaDSP/DSP.jl"><code>DSP</code></a></p><pre><code class="language-none">Filt(x,h;[blocksize=4096])</code></pre><p>Apply the given digital filter <code>h</code> (from <a href="https://github.com/JuliaDSP/DSP.jl"><code>DSP</code></a>) to signal <code>x</code>.</p><p><strong>Blocksize</strong></p><p>Blocksize determines the size of the buffer used when computing intermediate values of the filter. It need not normally be adjusted, though changing it can alter how efficient filter application is.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The non-lazy version of <code>Filt</code> is <code>filt</code> from the <a href="https://github.com/JuliaDSP/DSP.jl"><code>DSP</code></a> package. Proper methods have been defined such that it should be possible to call <code>filt</code> on a signal and get a signal back.</p><p>The argument order for <code>filt</code> follows a different convention, with <code>x</code> coming after the filter specification. In contrast, <code>Filt</code> uses the convention of keeping <code>x</code> as the first argument to make piping possible.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/filters.jl#LL22-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Normpower" href="#SignalOperators.Normpower"><code>SignalOperators.Normpower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Normpower(x)</code></pre><p>Return a signal with normalized power. That is, divide all frames by the root-mean-squared value of the entire signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/filters.jl#LL300-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.MapSignal" href="#SignalOperators.MapSignal"><code>SignalOperators.MapSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MapSignal(fn,arguments...;padding,bychannel)</code></pre><p>Apply <code>fn</code> across the frames of arguments, producing a signal of the output of <code>fn</code>. Shorter signals are padded to accommodate the longest finite-length signal. The function <code>fn</code> should treat each argument as a single number and return a single number. This operation is broadcast across all channels of the input. It is expected to be a type stable function.</p><p>Normally the signals are first promoted to have the same samle rate and the same number of channels using <a href="#SignalOperators.Uniform"><code>Uniform</code></a> (with <code>channels=true</code>).</p><p><strong>Cross-channel functions</strong></p><p>The function <code>fn</code> is normally broadcast across channels, but if you wish to treat each channel separately you can set <code>bychannel=false</code>. In this case the inputs to <code>fn</code> will be indexable objects (tuples or arrays) of all channel values for a given frame, and <code>fn</code> should return a type-stable tuple value (for a multi-channel or single-channel result) or a number (for a single-channel result only). For example, the following would swap the left and right channels.</p><pre><code class="language-julia">x = rand(10,2)
swapped = MapSignal(x,bychannel=false) do val
    val[2],val[1]
end</code></pre><p>When <code>bychannel=false</code> the channels of each signal are not promoted:</p><p><strong>Padding</strong></p><p>Padding determines how frames past the end of shorter signals are reported. The value of <code>padding</code> is passd to <a href="#SignalOperators.Pad"><code>Pad</code></a>. Its default value is determined by the value of <code>fn</code>. The default value for the four basic arithmetic operators is their identity (<code>one</code> for <code>*</code> and <code>zero</code> for <code>+</code>). These defaults are set on the basis of <code>fn</code> using <code>default_pad(fn)</code>. A fallback implementation of <code>default_pad</code> returns <code>zero</code>.</p><p>To define a new default for a specific function, just create a new method of <code>default_pad(fn)</code></p><pre><code class="language-julia">
myfun(x) = 2x + 3
SignalOperators.default_pad(::typeof(myfun)) = one
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL66-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.mapsignal" href="#SignalOperators.mapsignal"><code>SignalOperators.mapsignal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapsignal(fn,args...;padding,bychannel)</code></pre><p>Equivalent to <code>sink(MapSignal(fn,args...;padding,bychannel))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.MapSignal"><code>MapSignal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL135-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Mix" href="#SignalOperators.Mix"><code>SignalOperators.Mix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Mix(xs...)</code></pre><p>Sum all signals together, using <a href="#SignalOperators.MapSignal"><code>MapSignal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.mix" href="#SignalOperators.mix"><code>SignalOperators.mix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mix(xs...)</code></pre><p>Equivalent to <code>sink(Mix(xs...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Mix"><code>Mix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL273-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Amplify" href="#SignalOperators.Amplify"><code>SignalOperators.Amplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Amplify(xs...)</code></pre><p>Find the product, on a per-frame basis, for all signals <code>xs</code> using <a href="#SignalOperators.MapSignal"><code>MapSignal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL285-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.amplify" href="#SignalOperators.amplify"><code>SignalOperators.amplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">amplify(xs...)</code></pre><p>Equivalent to <code>sink(Amplify(xs...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Amplify"><code>Amplify</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL297-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.AddChannel" href="#SignalOperators.AddChannel"><code>SignalOperators.AddChannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AddChannel(xs...)</code></pre><p>Concatenate the channels of all signals into one signal, using <a href="#SignalOperators.MapSignal"><code>MapSignal</code></a>. This will result in a signal with <code>sum(nchannels,xs)</code> channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL309-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.addchannel" href="#SignalOperators.addchannel"><code>SignalOperators.addchannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addchannel(xs...)</code></pre><p>Equivalent to <code>sink(AddChannel(xs...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.AddChannel"><code>AddChannel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL324-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.SelectChannel" href="#SignalOperators.SelectChannel"><code>SignalOperators.SelectChannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SelectChannel(x,n)</code></pre><p>Select channel <code>n</code> of signal <code>x</code>, as a single-channel signal, using <a href="#SignalOperators.MapSignal"><code>MapSignal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL337-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.selectchannel" href="#SignalOperators.selectchannel"><code>SignalOperators.selectchannel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">selectchannel(xs...)</code></pre><p>Equivalent to <code>sink(SelectChannel(xs...))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.SelectChannel"><code>SelectChannel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/mapsignal.jl#LL351-L360">source</a></section></article><h3 id="Ramping-Operators-1"><a class="docs-heading-anchor" href="#Ramping-Operators-1">Ramping Operators</a><a class="docs-heading-anchor-permalink" href="#Ramping-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.RampOn" href="#SignalOperators.RampOn"><code>SignalOperators.RampOn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RampOn(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the onset of a signal, smoothly transitioning from 0 to full amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the Ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL139-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.rampon" href="#SignalOperators.rampon"><code>SignalOperators.rampon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rampon(x,[len],[fn])</code></pre><p>Equivalent to <code>sink(RampOn(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.RampOn"><code>RampOn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL161-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.RampOff" href="#SignalOperators.RampOff"><code>SignalOperators.RampOff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RampOff(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the offset of a signal, smoothly transitioning from full amplitude to 0 amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the Ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL174-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.rampoff" href="#SignalOperators.rampoff"><code>SignalOperators.rampoff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rampoff(x,[len],[fn])</code></pre><p>Equivalent to <code>sink(RampOff(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.RampOff"><code>RampOff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL196-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Ramp" href="#SignalOperators.Ramp"><code>SignalOperators.Ramp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Ramp(x,[len=10ms],[fn=x -&gt; sinpi(0.5x)])</code></pre><p>Ramp the onset and offset of a signal, smoothly transitioning from 0 to full amplitude over the course of <code>len</code> seconds at the start and from full to 0 amplitude over the course of <code>len</code> seconds.</p><p>The function determines the shape of the Ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL208-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ramp" href="#SignalOperators.ramp"><code>SignalOperators.ramp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ramp(x,[len],[fn])</code></pre><p>Equivalent to <code>sink(Ramp(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Ramp"><code>Ramp</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL231-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.FadeTo" href="#SignalOperators.FadeTo"><code>SignalOperators.FadeTo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">FadeTo(x,y,[len=10ms],[fn=x-&gt;sinpi(0.5x)])</code></pre><p>Append x to y, with a smooth transition lasting <code>len</code> seconds fading from <code>x</code> to <code>y</code> (so the total length is <code>duration(x) + duration(y) - len</code>).</p><p>This fade is accomplished with a <a href="#SignalOperators.RampOff"><code>RampOff</code></a> of <code>x</code> and a <a href="#SignalOperators.RampOn"><code>RampOn</code></a> for <code>y</code>. <code>fn</code> should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is <code>fn(0) == 0</code> and <code>fn(1) == 1</code>.</p><p>Both <code>len</code> and <code>fn</code> are optional arguments: either one or both can be specified, though <code>len</code> must occur before <code>fn</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL243-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.fadeto" href="#SignalOperators.fadeto"><code>SignalOperators.fadeto</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fadeto(x,y,[len],[fn])</code></pre><p>Equivalent to <code>sink(FadeTo(x,[len],[fn]))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.FadeTo"><code>FadeTo</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/ramps.jl#LL273-L282">source</a></section></article><h3 id="Reformatting-Operators-1"><a class="docs-heading-anchor" href="#Reformatting-Operators-1">Reformatting Operators</a><a class="docs-heading-anchor-permalink" href="#Reformatting-Operators-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ToFramerate" href="#SignalOperators.ToFramerate"><code>SignalOperators.ToFramerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ToFramerate(x,fs;blocksize)</code></pre><p>Change the frame rate of <code>x</code> to the given frame rate <code>fs</code>. The underlying implementation depends on whether the input is a computed or data signal, as determined by <a href="#SignalOperators.EvalTrait"><code>EvalTrait</code></a>.</p><p>Computed signals (e.g. <code>Signal(sin)</code>) are resampled exactly: the result is simply computed for more time points or fewer time points, so as to generate the appropriate number of frames.</p><p>Data-based signals (<code>Signal(rand(50,2))</code>) are resampled using filtering (akin to <code>DSP.resample</code>). In this case you can use the keyword arugment <code>blocksize</code> to change the analysis window used. See <a href="#SignalOperators.Filt"><code>Filt</code></a> for more details. Setting <code>blocksize</code> for a computed signal will succeed, but different <code>blocksize</code> values have no effect on the underlying implementation.</p><p><strong>Implementation</strong></p><p>You need only implement this function for custom signals for particular scenarios, described below.</p><p><strong>Custom Computed Signals</strong></p><p>If you implement a new sigal type that is a computed signal, you must implement <code>ToFramerate</code> with the following type signature.</p><pre><code class="language-julia">
function ToFramerate(x::MyCustomSignal,s::IsSignal{&lt;:Any,&lt;:Number},
    c::ComputedSignal,framerate;blocksize)

    ## ...
end</code></pre><p>The result should be a new version of the computed signal with the given frame rate.</p><p><strong>Handling missing frame rates</strong></p><p>If you implement a new signal type that can handle missing frame rate values, you will need to implement the following version of <code>ToFramerate</code> so that a known frame rate can be applied to a signal with a missing frame rate.</p><pre><code class="language-julia">
function ToFramerate(x::MyCustomSignal,s::IsSignal{&lt;:Any,Missing},
    evaltrait,framerate;blocksize)

    ## ...
end</code></pre><p>The result should be a new version of the signal with the specified frame rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL5-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.toframerate" href="#SignalOperators.toframerate"><code>SignalOperators.toframerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">toframerate(x,fs;blocksize)</code></pre><p>Equivalent to <code>sink(ToFramerate(x,fs;blocksize=blocksize))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.ToFramerate"><code>ToFramerate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL72-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ToChannels" href="#SignalOperators.ToChannels"><code>SignalOperators.ToChannels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ToChannels(x,ch)</code></pre><p>Force a signal to have <code>ch</code> number of channels, by Mixing channels together or broadcasting a single channel over multiple channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL124-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.tochannels" href="#SignalOperators.tochannels"><code>SignalOperators.tochannels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tochannels(x,ch)</code></pre><p>Equivalent to <code>sink(ToChannels(x,ch))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.ToFramerate"><code>ToFramerate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL136-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ToEltype" href="#SignalOperators.ToEltype"><code>SignalOperators.ToEltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ToEltype(x,T)</code></pre><p>Converts individual frames in signal <code>x</code> to type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.toeltype" href="#SignalOperators.toeltype"><code>SignalOperators.toeltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">toeltype(x,T)</code></pre><p>Equivalent to <code>sink(ToEltype(x,T))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.ToEltype"><code>ToEltype</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL186-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Format" href="#SignalOperators.Format"><code>SignalOperators.Format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Format(x,fs,ch)</code></pre><p>Efficiently convert both the framerate (<code>fs</code>) and channels <code>ch</code> of signal <code>x</code>. This selects an optimal ordering for <code>ToFramerate</code> and <code>ToChannels</code> to avoid redundant computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL198-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.format" href="#SignalOperators.format"><code>SignalOperators.format</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">format(x,fs,ch)</code></pre><p>Equivalent to <code>sink(Format(x,fs,ch))</code></p><p><strong>See also</strong></p><p><a href="#SignalOperators.Format"><code>Format</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL215-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.Uniform" href="#SignalOperators.Uniform"><code>SignalOperators.Uniform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Uniform(xs;channels=false)</code></pre><p>Promote the frame rate (and optionally the number of channels) to be the highest frame rate (and optionally highest channel count) of the iterable of signals <code>xs</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Uniform</code> rarely needs to be called directly. It is called implicitly on all passed signals, within the body of operators such as <a href="#SignalOperators.MapSignal"><code>MapSignal</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/reformatting.jl#LL227-L240">source</a></section></article><h2 id="Custom-Signals-1"><a class="docs-heading-anchor" href="#Custom-Signals-1">Custom Signals</a><a class="docs-heading-anchor-permalink" href="#Custom-Signals-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.SignalTrait" href="#SignalOperators.SignalTrait"><code>SignalOperators.SignalTrait</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SiganlOperators.SignalTrait(::Type{T}) where T</code></pre><p>Returns either <code>nothing</code> if the type T should not be considered a signal (the default) or <a href="#SignalOperators.IsSignal"><code>IsSignal</code></a> to indicate the signal Format for this signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.IsSignal" href="#SignalOperators.IsSignal"><code>SignalOperators.IsSignal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SignalOperators.IsSignal{T,Fs,L}</code></pre><p>Represents the Format of a signal type with three type parameters:</p><ul><li><code>T</code> - The <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of the signal.</li><li><code>Fs</code> - The type of the framerate. It should be either <code>Float64</code> or   <code>Missing</code>.</li><li><code>L</code> - The type of the length of the signal. It should be either</li></ul><p><code>InfiniteLength</code>, <code>Missing</code> or <code>Int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.EvalTrait" href="#SignalOperators.EvalTrait"><code>SignalOperators.EvalTrait</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SiganlOperators.EvalTrait(x)</code></pre><p>Indicates whether the signal is a <code>DataSignal</code> or <code>ComputedSignal</code>. Data signals represent frames concretely as a set of frames. Examples include arrays and numbers. Data signals generally return themselves, or some wrapper type when <code>sink</code> is called on them. Computed signals are any signal that invovles some intermediate computation, in which frames must be computued on the fly. Calls to <code>sink</code> on a computed signal results in some new, data signal. Most signals returned by a signal operator are computed signals.</p><p>Computed signals have the extra responsibility of implementing <a href="#SignalOperators.ToFramerate"><code>ToFramerate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/signal.jl#LL216-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.nextblock" href="#SignalOperators.nextblock"><code>SignalOperators.nextblock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.nextblock(x,maxlength,skip,[block])</code></pre><p>Retrieve the next block of frames for signal <code>x</code>. The final, fourth argument is optional. If it is left out, nextblock returns the first block of the signal. The resulting block must has no more than <code>maxlength</code> frames, but may have fewer frames than that; it should not have zero frames unless <code>maxlength == 0</code>. If <code>skip == true</code>, it is guaranted that <a href="#SignalOperators.frame"><code>frame</code></a> will never be called on the returned block. The value of <code>skip</code> is <code>true</code>, for example, when skipping blocks during a call to <a href="#SignalOperators.After"><code>After</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL163-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.frame" href="#SignalOperators.frame"><code>SignalOperators.frame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.frame(x,block,i)</code></pre><p>Retrieves the frame at index <code>i</code> of the given block of signal <code>x</code>. A frame is one or more channels of <code>channel_eltype(x)</code> values. The return value should be an indexable object (e.g. a number, tuple or array) of these channel values. This method should be implemented by blocks of <a href="../custom_signal/#custom_signals-1">custom signals</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL193-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.timeslice" href="#SignalOperators.timeslice"><code>SignalOperators.timeslice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.timeslice(x::AbstractArray,indices)</code></pre><p>Extract the slice of x with the given time indices.</p><p><a href="../custom_signal/#custom_signals-1">Custom signals</a> can implement this method if the signal is an <code>AbstractArray</code> allowing the use of a fallback implementation of <a href="#SignalOperators.nextblock"><code>SignalOperators.nextblock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.ArrayBlock" href="#SignalOperators.ArrayBlock"><code>SignalOperators.ArrayBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArrayBlock{A,S}(data::A,state::S)</code></pre><p>A straightforward implementation of blocks as an array and a custom state. The array allows a generic implementation of <a href="#SignalOperators.nframes"><code>nframes</code></a> and <a href="#SignalOperators.frame"><code>SignalOperators.frame</code></a>. The fields of this struct are <code>data</code> and <code>state</code>.</p><p><a href="../custom_signal/#custom_signals-1">Custom signals</a> can return an <code>ArrayBlock</code> from <a href="#SignalOperators.nextblock"><code>SignalOperators.nextblock</code></a> to allow for fallback implementations of <a href="#SignalOperators.nframes"><code>nframes</code></a> and <a href="#SignalOperators.frame"><code>SignalOperators.frame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/arrays.jl#LL100-L112">source</a></section></article><h2 id="Custom-Sinks-1"><a class="docs-heading-anchor" href="#Custom-Sinks-1">Custom Sinks</a><a class="docs-heading-anchor-permalink" href="#Custom-Sinks-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.initsink" href="#SignalOperators.initsink"><code>SignalOperators.initsink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.initsink(x,::Type{T},len)</code></pre><p>Initialize an object of type T so that it can store the first <code>len</code> frames of signal <code>x</code>.</p><p>If you wish an object to serve as a <a href="../custom_sink/#custom_sinks-1">custom sink</a> you can implement this method. You should probably use <a href="#SignalOperators.nchannels"><code>nchannels</code></a> and <a href="#SignalOperators.channel_eltype"><code>channel_eltype</code></a> of <code>x</code> to determine how to initialize the object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SignalOperators.sink_helper!" href="#SignalOperators.sink_helper!"><code>SignalOperators.sink_helper!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SignalOperators.sink_helper!(result,written,x,block)</code></pre><p>Write the given <code>block</code> of frames from signal <code>x</code> to <code>result</code> given that a total of <code>written</code> frames have already been written to the result.</p><p>This method should be fast: i.e. a for loop using @simd and @inbounds. It should call <a href="#SignalOperators.nframes"><code>nframes</code></a> and <a href="#SignalOperators.frame"><code>SignalOperators.frame</code></a> on the block to write the frames. <strong>Do not call <code>frame</code> more than once for each index of the block</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/haberdashPI/SignalOperators.jl/blob/e2e294dcdb05e86b5e0fcfa5d2ad7e6a98dc3b8b/src/sink.jl#LL227-L239">source</a></section></article><p>```</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_sink/">« Custom Sinks</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 3 January 2020 12:16">Friday 3 January 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
