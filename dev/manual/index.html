<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SignalOperators.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SignalOperators.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Key-concepts-1"><span>Key concepts</span></a></li><li><a class="tocitem" href="#Signal-generation-1"><span>Signal generation</span></a></li><li><a class="tocitem" href="#Signal-inspection-1"><span>Signal inspection</span></a></li><li><a class="tocitem" href="#Signal-operators-1"><span>Signal operators</span></a></li></ul></li><li><a class="tocitem" href="../custom_signal/">Custom Signals</a></li><li><a class="tocitem" href="../custom_sink/">Custom Sinks</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/haberdashPI/SignalOperators.jl/blob/master/docs/src/manual.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual-1"><a class="docs-heading-anchor" href="#Manual-1">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-1" title="Permalink"></a></h1><p>SignalOperators is composed of a set of functions for generating, inspecting and operating over signals. Here, a &quot;signal&quot; is represented as a number of channels (e.g. left and right speaker) with values (e.g. <code>Float64</code>) sampled regularly in time (e.g. every 100th of a second, or 100 Hz).</p><h2 id="Key-concepts-1"><a class="docs-heading-anchor" href="#Key-concepts-1">Key concepts</a><a class="docs-heading-anchor-permalink" href="#Key-concepts-1" title="Permalink"></a></h2><p>There are several important concepts employed across the public interface. Let&#39;s step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts.</p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz) |&gt; until(5s) |&gt; ramp |&gt; normpower |&gt; amplify(-20dB)</code></pre><p>This example creates a 1 kHz pure-tone (sine wave) that lasts 5 seconds. Its amplitude is 20 dB lower than a signal with unit 1 power.</p><p>There are a few things going on here: piping, the use of units, infinite length signals, and unspecified frame rates.</p><h3 id="Piping-1"><a class="docs-heading-anchor" href="#Piping-1">Piping</a><a class="docs-heading-anchor-permalink" href="#Piping-1" title="Permalink"></a></h3><p>Almost all of the functions implemented in SignalOperators can be piped. This means that instead of passing the first argument to a function, you can pipe it using <code>|&gt;</code>. For example, the two statements below have the same meaning.</p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz) |&gt; until(5s)
sound1 = until(signal(sin,ω=1kHz),5s)</code></pre><p>The use of piping makes it easier to read the sequence of operations that are performed on the signal.</p><h3 id="Units-1"><a class="docs-heading-anchor" href="#Units-1">Units</a><a class="docs-heading-anchor-permalink" href="#Units-1" title="Permalink"></a></h3><p>In any place where a function needs a time or a frequency, it can be specified in appropriate units. There are many places where units can be passed. They all have a default assumed unit, if a plain number without units is passed. The default units are seconds, Hertz, and radians as appropriate for the given argument.</p><pre><code class="language-julia">sound1 = signal(sin,ω=1kHz)
sound1 = signal(sin,ω=1000)</code></pre><p>Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants, you must call <code>using SignalOperators.Units</code>. This exports the following units: <code>frames</code>, <code>kframes</code>, <code>Hz</code>, <code>kHz</code> <code>s</code>, <code>ms</code>, <code>rad</code>, <code>°</code>, and <code>dB</code>. You can just include the ones you want using e.g. <code>using SignalOperators.Units: Hz</code>, or you can include more by adding the <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful</code></a> package to your project and adding the desired units from there. For example, <code>using Unitful: MHz</code> would include mega-Hertz frequencies (not usually useful for signals that are sounds). Most of the default units have been re-exported from <code>Unitful</code>. However, the <code>frames</code> unit and its derivatives (e.g. <code>kframes</code>) are unique  to the SignalOperators package. They allow you to specify the time in terms of the number of frames: e.g. at a frame rate of 100 Hz, <code>2s == 200frames</code>. Other powers of ten are represented for <code>frames</code>, (e.g. <code>Mframes</code> for mega-frames) but they are not exported (e.g. you would have to call <code>SignalOperators.Units: Mframes</code> before using <code>20Mframes</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can find the available powers-of-ten for units in <code>Unitful.prefixdict</code></p></div></div><p>Note that the output of functions to inspect a signal (e.g. <code>duration</code>, <code>framerate</code>) are bare values in the default unit (e.g. seconds or Hertz). No unit is explicitly provided by the return value.</p><h4 id="Decibels-1"><a class="docs-heading-anchor" href="#Decibels-1">Decibels</a><a class="docs-heading-anchor-permalink" href="#Decibels-1" title="Permalink"></a></h4><p>You can pass an amplification value as a unitless or a unitful value in <code>dB</code>; a unitless value is not assumed to be in decibels. Instead, it&#39;s assumed to be the actual ratio by which you wish to multiply the signal. For example, <code>amplify(x,2)</code> will make <code>x</code> twice as loud.</p><h3 id="Infinite-lengths-1"><a class="docs-heading-anchor" href="#Infinite-lengths-1">Infinite lengths</a><a class="docs-heading-anchor-permalink" href="#Infinite-lengths-1" title="Permalink"></a></h3><p>Some of the ways you can define a signal lead to an infinite length signal. You cannot store an infinite signal. It is represented as a function of some kind. Operations on signals are generally lazy, meaning the frames of the signal aren&#39;t computed until necessary. To allow actual data to be created from a signal, you have to specify the length, using <a href="../reference/#SignalOperators.until"><code>until</code></a>. For example, when using <code>signal(sin)</code>, the signal is an infinite length sine wave. That&#39;s why, in the example above, we use <a href="../reference/#SignalOperators.until"><code>until</code></a> to specify the length, as follows.</p><pre><code class="language-julia">signal(sin,ω=1kHz) |&gt; until(5s)</code></pre><p>Infinite lengths are represented as the value <a href="../reference/#SignalOperators.inflen"><code>inflen</code></a>. This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc...</p><h3 id="Unspecified-frame-rates-1"><a class="docs-heading-anchor" href="#Unspecified-frame-rates-1">Unspecified frame rates</a><a class="docs-heading-anchor-permalink" href="#Unspecified-frame-rates-1" title="Permalink"></a></h3><p>You may notice that the above signal has no defined frame rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined frame rate, the unspecified frame rate will be resolved to that same rate (see signal promotion, below). If there is no defined frame rate by the time you call <a href="../reference/#SignalOperators.sink"><code>sink</code></a>, you can specify it then.</p><h3 id="Sinking-1"><a class="docs-heading-anchor" href="#Sinking-1">Sinking</a><a class="docs-heading-anchor-permalink" href="#Sinking-1" title="Permalink"></a></h3><p>Once you have defined a signal, you can create some concrete sequence of frames from it. This is done using <a href="../reference/#SignalOperators.sink"><code>sink</code></a>. When <code>sink</code> is simply passed a signal, the resulting value is itself a signal. This means you can continue to processes it with more operators. The function <a href="../reference/#SignalOperators.sink"><code>sink</code></a> can also write data to a file. Sink must consume a finite-length signal. To store the five second signal in the above example to &quot;example.wav&quot; we could write the following.</p><pre><code class="language-julia">sound1 |&gt; sink(&quot;example.wav&quot;)</code></pre><p>In this case <code>sound1</code> had no defined frame rate, so the default frame rate of 44.1khz will be used. The absence of an explicit frame rate will raise a warning.</p><h3 id="Signal-promotion-1"><a class="docs-heading-anchor" href="#Signal-promotion-1">Signal promotion</a><a class="docs-heading-anchor-permalink" href="#Signal-promotion-1" title="Permalink"></a></h3><p>A final concept, which is not as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different number of channels or different frame rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don&#39;t have to worry about the specific format of the signal, and you won&#39;t loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using <a href="../reference/#SignalOperators.tochannels"><code>tochannels</code></a> or <a href="../reference/#SignalOperators.toframerate"><code>toframerate</code></a>).</p><h2 id="Signal-generation-1"><a class="docs-heading-anchor" href="#Signal-generation-1">Signal generation</a><a class="docs-heading-anchor-permalink" href="#Signal-generation-1" title="Permalink"></a></h2><p>There are four basic types that can be interpreted as signals: numbers, arrays, functions and files. Internally the function <a href="../reference/#SignalOperators.signal"><code>signal</code></a> is called on any object passed to a function that inspects or operates on a signal; you can call <a href="../reference/#SignalOperators.signal"><code>signal</code></a> yourself if you want to specify more information. For example, you may want to provide the exact frame rate the signal should be interpreted to have.</p><h3 id="Numbers-1"><a class="docs-heading-anchor" href="#Numbers-1">Numbers</a><a class="docs-heading-anchor-permalink" href="#Numbers-1" title="Permalink"></a></h3><p>A number is treated as an infinite length signal, with unknown frame rate.</p><pre><code class="language-julia">1 |&gt; until(1s) |&gt; sink(framerate=10Hz) == ones(10)</code></pre><h3 id="Arrays-1"><a class="docs-heading-anchor" href="#Arrays-1">Arrays</a><a class="docs-heading-anchor-permalink" href="#Arrays-1" title="Permalink"></a></h3><p>A standard array is treated as a finite signal with unknown frame rate.</p><pre><code class="language-julia">rand(10,2) |&gt; sink(framerate=10Hz) |&gt; duration == 1</code></pre><p>An <code>AxisArray</code> or <code>SampleBuf</code> (form <a href="https://github.com/JuliaAudio/SampledSignals.jl"><code>SampledSignals</code></a>) is treated as a finite signal with a known frame rate (and is the default output of <a href="../reference/#SignalOperators.sink"><code>sink</code></a>)</p><pre><code class="language-julia">using AxisArrays
x = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))
framerate(x) == 10</code></pre><h3 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h3><p>A single argument function of time (in seconds) can be treated as an infinite signal. It can be also be a function of radians if you specify a frequency using <code>ω</code> (or <code>frequency</code>). See <a href="../reference/#SignalOperators.signal"><code>signal</code></a>&#39;s documentation for more details.</p><pre><code class="language-julia">signal(sin,ω=1kHz) |&gt; duration |&gt; isinf == true</code></pre><p>A small exception to this is <code>randn</code>. It can be used directly as a signal with unknown frame rate.</p><pre><code class="language-julia">randn |&gt; duration == isinf</code></pre><h3 id="Files-1"><a class="docs-heading-anchor" href="#Files-1">Files</a><a class="docs-heading-anchor-permalink" href="#Files-1" title="Permalink"></a></h3><p>A file is interpreted as a WAV audio file to be loaded into memory. You must include the <code>WAV</code> package for this to work.</p><pre><code class="language-julia">using WAV
x = signal(&quot;example.wav&quot;)</code></pre><h2 id="Signal-inspection-1"><a class="docs-heading-anchor" href="#Signal-inspection-1">Signal inspection</a><a class="docs-heading-anchor-permalink" href="#Signal-inspection-1" title="Permalink"></a></h2><p>You can examine the properties of a signal using <a href="../reference/#SignalOperators.nframes"><code>nframes</code></a>, <a href="../reference/#SignalOperators.nchannels"><code>nchannels</code></a>, <a href="../reference/#SignalOperators.framerate"><code>framerate</code></a>, and <a href="../reference/#SignalOperators.duration"><code>duration</code></a>.</p><h2 id="Signal-operators-1"><a class="docs-heading-anchor" href="#Signal-operators-1">Signal operators</a><a class="docs-heading-anchor-permalink" href="#Signal-operators-1" title="Permalink"></a></h2><p>There are several categories of signal operators: extending, cutting, filtering, ramping, and mapping.</p><h3 id="Extending-1"><a class="docs-heading-anchor" href="#Extending-1">Extending</a><a class="docs-heading-anchor-permalink" href="#Extending-1" title="Permalink"></a></h3><p>You can extend a signal using <a href="../reference/#SignalOperators.pad"><code>pad</code></a> or <a href="../reference/#SignalOperators.append"><code>append</code></a>. A padded signal becomes infinite by appending the signal by a repeated value, usually <code>one</code> or <code>zero</code>. You can append two or more signals (or <a href="../reference/#SignalOperators.prepend"><code>prepend</code></a>) so they occur one after another.</p><pre><code class="language-julia">pad(x,zero) |&gt; duration |&gt; isinf == true
append(x,y,z) |&gt; duration == duration(x) + duration(y) + duration(z)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You cannot append more than one new signal within a pipe. That is, the following will throw an error.</p><pre><code class="language-julia"># Don&#39;t do this!
x |&gt; append(y,z)</code></pre><p>This is because <code>append(y,z)</code> does not return a function to be piped (as <code>append(y)</code> does). It returns a signal with <code>y</code> followed by <code>z</code>. You can instead call this as follows.</p><pre><code class="language-julia"># This will do what you want!
x |&gt; append(y) |&gt; append(z)</code></pre></div></div><h3 id="Cutting-1"><a class="docs-heading-anchor" href="#Cutting-1">Cutting</a><a class="docs-heading-anchor-permalink" href="#Cutting-1" title="Permalink"></a></h3><p>You can cut signals apart, removing either the end of the signal (<a href="../reference/#SignalOperators.until"><code>until</code></a>) or the beginning (<a href="../reference/#SignalOperators.after"><code>after</code></a>). The operations are exact compliments of one another.</p><pre><code class="language-julia">append(until(x,2s),after(x,2s)) |&gt; nframes == nframes(x)</code></pre><h3 id="Filtering-1"><a class="docs-heading-anchor" href="#Filtering-1">Filtering</a><a class="docs-heading-anchor-permalink" href="#Filtering-1" title="Permalink"></a></h3><p>You can filter signals, removing undesired frequencies using <a href="../reference/#SignalOperators.lowpass"><code>lowpass</code></a>, <a href="../reference/#SignalOperators.highpass"><code>highpass</code></a>, <a href="../reference/#SignalOperators.bandpass"><code>bandpass</code></a>, <a href="../reference/#SignalOperators.bandstop"><code>bandstop</code></a> and <a href="../reference/#SignalOperators.filtersignal"><code>filtersignal</code></a>. The latter allows the use of any arbitrary filter defined using <code>DSP</code>.</p><pre><code class="language-julia">signal(randn) |&gt; lowpass(20Hz)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you write <code>using DSP</code> you will have to also write <code>dB = SignalOperators.Units.dB</code> if you want to make use of the proper meaning of <code>dB</code> for <code>SignalOperators</code>: <code>DSP</code> also defines <code>dB</code>.</p></div></div><p>An unusual filter is <a href="../reference/#SignalOperators.normpower"><code>normpower</code></a>: it computes the root mean squared power of the signal and then normalizes each frame by that value.</p><h3 id="Ramping-1"><a class="docs-heading-anchor" href="#Ramping-1">Ramping</a><a class="docs-heading-anchor-permalink" href="#Ramping-1" title="Permalink"></a></h3><p>A ramp allows for smooth transitions between 0 amplitude and the full amplitude of the signal. It is useful to avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.</p><pre><code class="language-julia">signal(sin,ω=2kHz) |&gt; until(5s) |&gt; ramp</code></pre><p>You can ramp only the start of a signal (<a href="../reference/#SignalOperators.rampon"><code>rampon</code></a>), or the end of it (<a href="../reference/#SignalOperators.rampoff"><code>rampoff</code></a>) and you can use ramps to create a smooth transition between two signals (<a href="../reference/#SignalOperators.fadeto"><code>fadeto</code></a>).</p><h3 id="Mapping-1"><a class="docs-heading-anchor" href="#Mapping-1">Mapping</a><a class="docs-heading-anchor-permalink" href="#Mapping-1" title="Permalink"></a></h3><p>Probably the most powerful operator is <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a>. It works a lot like <code>map</code> but automatically promotes the signals, as with all operators, <em>and</em> it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest <em>finite</em>-length signal.</p><pre><code class="language-julia">a = signal(sin,ω=2kHz) |&gt; until(2s)
b = signal(sin,ω=1kHz) |&gt; until(3s)
a_minus_b = mapsignal(-,a,b)</code></pre><p>The function <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a> cannot itself be piped, due to ambiguity in the arguments, but shortcuts for this function have been provided for addition (<a href="../reference/#SignalOperators.mix"><code>mix</code></a>) and multiplication (<a href="../reference/#SignalOperators.amplify"><code>amplify</code></a>), the two most common operations, and these two shortcuts have piped versions available.</p><pre><code class="language-julia">a_plus_b = a |&gt; mix(b)
a_times_b = a |&gt; amplify(b)</code></pre><p>You can also add or select out channels using <a href="../reference/#SignalOperators.addchannel"><code>addchannel</code></a> and <a href="../reference/#SignalOperators.channel"><code>channel</code></a>, which are defined in terms of calls to <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a>. These use a variant of <a href="../reference/#SignalOperators.mapsignal"><code>mapsignal</code></a> where the keyword <code>bychannel</code> is set to <code>false</code> (see <code>mapsignal</code>&#39;s documentation for details).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../custom_signal/">Custom Signals »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 21 December 2019 13:44">Saturday 21 December 2019</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
