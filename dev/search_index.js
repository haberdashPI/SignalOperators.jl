var documenterSearchIndex = {"docs":
[{"location":"custom_sink/#custom_sinks-1","page":"Custom Sinks","title":"Custom Sinks","text":"","category":"section"},{"location":"custom_sink/#","page":"Custom Sinks","title":"Custom Sinks","text":"You can create custom sinks, which can be passed to sink or sink! by defining two methods: SignalOperators.initsink and SignalOperators.sink_helper!. The first method is called when a call to sink is made (e.g. sink(MyCustomSink)). The second method is called inside sink! and provides the core operation to write blocks of frames to the sink.","category":"page"},{"location":"custom_sink/#","page":"Custom Sinks","title":"Custom Sinks","text":"Implementing initsink is not strictly necessary. If you do not implement initsink you will only be able to write to the sink using sink!.","category":"page"},{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"SignalOperators is composed of a set of functions for generating, inspecting and operating over signals. Here, a \"signal\" is represented as a number of channels (e.g. left and right speaker) with values (e.g. Float64) sampled regularly in time (e.g. every 100th of a second, or 100 Hz).","category":"page"},{"location":"manual/#Key-concepts-1","page":"Manual","title":"Key concepts","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several important concepts employed across the public interface. Let's step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"This example creates a 1 kHz pure-tone (sine wave) that lasts 5 seconds. Its amplitude is 20 dB lower than a signal with unit 1 power.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are a few things going on here: piping, the use of units, infinite length signals, and unspecified frame rates.","category":"page"},{"location":"manual/#Piping-1","page":"Manual","title":"Piping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Almost all of the functions implemented in SignalOperators can be piped. This means that instead of passing the first argument to a function, you can pipe it using |>. For example, the two statements below have the same meaning.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s)\nsound1 = until(signal(sin,ω=1kHz),5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The use of piping makes it easier to read the sequence of operations that are performed on the signal.","category":"page"},{"location":"manual/#Units-1","page":"Manual","title":"Units","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In any place where a function needs a time or a frequency, it can be specified in appropriate units. There are many places where units can be passed. They all have a default assumed unit, if a plain number without units is passed. The default units are seconds, Hertz, and radians as appropriate for the given argument.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz)\nsound1 = signal(sin,ω=1000)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants, you must call using SignalOperators.Units. This exports the following units: frames, kframes, Hz, kHz s, ms, rad, °, and dB. You can just include the ones you want using e.g. using SignalOperators.Units: Hz, or you can include more by adding the Unitful package to your project and adding the desired units from there. For example, using Unitful: MHz would include mega-Hertz frequencies (not usually useful for signals that are sounds). Most of the default units have been re-exported from Unitful. However, the frames unit and its derivatives (e.g. kframes) are unique  to the SignalOperators package. They allow you to specify the time in terms of the number of frames: e.g. at a frame rate of 100 Hz, 2s == 200frames. Other powers of ten are represented for frames, (e.g. Mframes for mega-frames) but they are not exported (e.g. you would have to call SignalOperators.Units: Mframes before using 20Mframes).","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nYou can find the available powers-of-ten for units in Unitful.prefixdict","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Note that the output of functions to inspect a signal (e.g. duration, framerate) are bare values in the default unit (e.g. seconds or Hertz). No unit is explicitly provided by the return value.","category":"page"},{"location":"manual/#Decibels-1","page":"Manual","title":"Decibels","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can pass an amplification value as a unitless or a unitful value in dB; a unitless value is not assumed to be in decibels. Instead, it's assumed to be the actual ratio by which you wish to multiply the signal. For example, amplify(x,2) will make x twice as loud.","category":"page"},{"location":"manual/#Infinite-lengths-1","page":"Manual","title":"Infinite lengths","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Some of the ways you can define a signal lead to an infinite length signal. You cannot store an infinite signal. It is represented as a function of some kind. Operations on signals are generally lazy, meaning the frames of the signal aren't computed until necessary. To allow actual data to be created from a signal, you have to specify the length, using until. For example, when using signal(sin), the signal is an infinite length sine wave. That's why, in the example above, we use until to specify the length, as follows.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> until(5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Infinite lengths are represented as the value inflen. This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc...","category":"page"},{"location":"manual/#Unspecified-frame-rates-1","page":"Manual","title":"Unspecified frame rates","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You may notice that the above signal has no defined frame rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined frame rate, the unspecified frame rate will be resolved to that same rate (see signal promotion, below). If there is no defined frame rate by the time you call sink, you can specify it then.","category":"page"},{"location":"manual/#Sinking-1","page":"Manual","title":"Sinking","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Once you have defined a signal, you can create some concrete sequence of frames from it. This is done using sink. When sink is simply passed a signal, the resulting value is itself a signal. This means you can continue to processes it with more operators. The function sink can also write data to a file. Sink must consume a finite-length signal. To store the five second signal in the above example to \"example.wav\" we could write the following.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 |> sink(\"example.wav\")","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In this case sound1 had no defined frame rate, so the default frame rate of 44.1khz will be used. The absence of an explicit frame rate will raise a warning.","category":"page"},{"location":"manual/#Signal-promotion-1","page":"Manual","title":"Signal promotion","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A final concept, which is not as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different number of channels or different frame rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don't have to worry about the specific format of the signal, and you won't loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using tochannels or toframerate).","category":"page"},{"location":"manual/#Signal-generation-1","page":"Manual","title":"Signal generation","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are four basic types that can be interpreted as signals: numbers, arrays, functions and files. Internally the function signal is called on any object passed to a function that inspects or operates on a signal; you can call signal yourself if you want to specify more information. For example, you may want to provide the exact frame rate the signal should be interpreted to have.","category":"page"},{"location":"manual/#Numbers-1","page":"Manual","title":"Numbers","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A number is treated as an infinite length signal, with unknown frame rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"1 |> until(1s) |> sink(framerate=10Hz) == ones(10)","category":"page"},{"location":"manual/#Arrays-1","page":"Manual","title":"Arrays","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A standard array is treated as a finite signal with unknown frame rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"rand(10,2) |> sink(framerate=10Hz) |> duration == 1","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An AxisArray or SampleBuf (form SampledSignals) is treated as a finite signal with a known frame rate (and is the default output of sink)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using AxisArrays\nx = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))\nframerate(x) == 10","category":"page"},{"location":"manual/#Functions-1","page":"Manual","title":"Functions","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A single argument function of time (in seconds) can be treated as an infinite signal. It can be also be a function of radians if you specify a frequency using ω (or frequency). See signal's documentation for more details.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> duration |> isinf == true","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A small exception to this is randn. It can be used directly as a signal with unknown frame rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"randn |> duration == isinf","category":"page"},{"location":"manual/#Files-1","page":"Manual","title":"Files","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A file is interpreted as a WAV audio file to be loaded into memory. You must include the WAV package for this to work.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using WAV\nx = signal(\"example.wav\")","category":"page"},{"location":"manual/#Signal-inspection-1","page":"Manual","title":"Signal inspection","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can examine the properties of a signal using nframes, nchannels, framerate, and duration.","category":"page"},{"location":"manual/#Signal-operators-1","page":"Manual","title":"Signal operators","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several categories of signal operators: extending, cutting, filtering, ramping, and mapping.","category":"page"},{"location":"manual/#Extending-1","page":"Manual","title":"Extending","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can extend a signal using pad or append. A padded signal becomes infinite by appending the signal by a repeated value, usually one or zero. You can append two or more signals (or prepend) so they occur one after another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"pad(x,zero) |> duration |> isinf == true\nappend(x,y,z) |> duration == duration(x) + duration(y) + duration(z)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nYou cannot append more than one new signal within a pipe. That is, the following will throw an error.# Don't do this!\nx |> append(y,z)This is because append(y,z) does not return a function to be piped (as append(y) does). It returns a signal with y followed by z. You can instead call this as follows.# This will do what you want!\nx |> append(y) |> append(z)","category":"page"},{"location":"manual/#Cutting-1","page":"Manual","title":"Cutting","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can cut signals apart, removing either the end of the signal (until) or the beginning (after). The operations are exact compliments of one another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"append(until(x,2s),after(x,2s)) |> nframes == nframes(x)","category":"page"},{"location":"manual/#Filtering-1","page":"Manual","title":"Filtering","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can filter signals, removing undesired frequencies using lowpass, highpass, bandpass, bandstop and filtersignal. The latter allows the use of any arbitrary filter defined using DSP.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(randn) |> lowpass(20Hz)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"warning: Warning\nIf you write using DSP you will have to also write dB = SignalOperators.Units.dB if you want to make use of the proper meaning of dB for SignalOperators: DSP also defines dB.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An unusual filter is normpower: it computes the root mean squared power of the signal and then normalizes each frame by that value.","category":"page"},{"location":"manual/#Ramping-1","page":"Manual","title":"Ramping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A ramp allows for smooth transitions between 0 amplitude and the full amplitude of the signal. It is useful to avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=2kHz) |> until(5s) |> ramp","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can ramp only the start of a signal (rampon), or the end of it (rampoff) and you can use ramps to create a smooth transition between two signals (fadeto).","category":"page"},{"location":"manual/#Mapping-1","page":"Manual","title":"Mapping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Probably the most powerful operator is mapsignal. It works a lot like map but automatically promotes the signals, as with all operators, and it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest finite-length signal.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a = signal(sin,ω=2kHz) |> until(2s)\nb = signal(sin,ω=1kHz) |> until(3s)\na_minus_b = mapsignal(-,a,b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The function mapsignal cannot itself be piped, due to ambiguity in the arguments, but shortcuts for this function have been provided for addition (mix) and multiplication (amplify), the two most common operations, and these two shortcuts have piped versions available.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a_plus_b = a |> mix(b)\na_times_b = a |> amplify(b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can also add or select out channels using addchannel and channel, which are defined in terms of calls to mapsignal. These use a variant of mapsignal where the keyword bychannel is set to false (see mapsignal's documentation for details).","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Signal-Generation-1","page":"Reference","title":"Signal Generation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"signal\nsink\nsink!","category":"page"},{"location":"reference/#SignalOperators.signal","page":"Reference","title":"SignalOperators.signal","text":"signal(x,[framerate])\n\nCoerce x to be a signal, optionally specifying its frame rate (usually in Hz). All signal operators first call signal(x) for each argument. This means you only need to call signal when you want to pass additional arguments to it.\n\nnote: Note\nIf you pipe signal and pass a frame rate, you must specify the units of the frame rate (e.g. x |> signal(20Hz)). A unitless number is always interpreted as a constant, infinite-length signal (see below).\n\nnote: Note\nIf you are implementing signal for a custom signal, you will need to support the second argument of signal by specifying fs::Union{Number,Missing}=missing, or equivalent, as your second argument.\n\nThe type of objects that can be coerced to signals are as follows.\n\n\n\n\n\nFilenames\n\nA string with a filename ending with an appropriate filetype can be read in as a signal. You will need to call import or using on the backend for reading the file.\n\nAvailable backends include the following pacakges\n\nWAV\nLibSndFile\n\n\n\n\n\nExisting signals\n\nAny existing signal just returns itself from signal. If a frame rate is specified it will be set if x has an unknown frame rate. If it has a known frame rate and doesn't match framerate(x) an error will be thrown. If you want to change the frame rate of a signal use toframerate.\n\n\n\n\n\nNumbers\n\nNumbers can be treated as infinite length, constant signals of unknown frame rate.\n\n\n\n\n\nArrays\n\nAny array can be interpreted as a signal. By default the first dimension is time, the second channels and their frame rate is a missing value. Some array types change this default behavior.\n\nAxisArrays, if they have an\n\naxis labeled time and one or zero additional axes, can be treated as a signal. The time dimension must be represented using on object with the step function defined (e.g. any AbstractRange object).\n\nSampleBuf objects are\n\nalso properly interpreted as signals, as per the conventions employed for its package.\n\nDimensionalArrays can be\n\ntreated as signals if there is a Time dimension, which must be represented using an object with the step function defined (e.g. AbstractRange)\n\n\n\n\n\nArray & Number\n\nA tuple of an array and a number can be interepted as a signal. The first dimension is time, the second channels, and the number determines the frame rate (in Hertz).\n\n\n\n\n\nFunctions\n\nsignal(fn,[framerate];[ω/frequency],[ϕ/phase])\n\nFunctions can define infinite length signals of known or unknown frame rate. The function fn can either return a number or, for multi-channel signals, a tuple of values.\n\nThe input to fn is either a phase value or a time value. If a frequency is specified (using either the ω or frequency keyword), the input to fn will be a phase value in radians, ranging from 0 to 2π. If no frequency is specified the value passed to fn is the time in seconds. Specifying phase (by the ϕ or phase keyword) will first add that value to the input before passing it to fn. When frequency is specified, the phase is assumed to be in units of radians (but you can also pass degrees by using ° or a unit of time (e.g. s for seconds)). When frequency is not specified the phase is assumed to be in units of seconds.\n\n\n\n\n\nIf fn == randn no frequency or phase can be specified. Instead there is a single keyword argument, rng, which allows you to specify the random number generator; rng defaults to Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink","page":"Reference","title":"SignalOperators.sink","text":"sink([signal],[to];duration,framerate)\n\nCreates a given type of object (to) from a signal. By default the type of the resulting sink is determined by the type of the underlying data of the signal: e.g. if x is a SampleBuf object then sink(mix(x,2)) is also a SampleBuf object. If there is no underlying data (signal(sin) |> sink) then the the type for the current backend is used (SignalOperators.set_array_backend).\n\nArray return type\n\nWhen to is set to Array the return value is actually a tuple of an array and a second value, which is the frame rate in Hertz. Thus, if you use the default Array backend, you should use sink as follows:\n\nx,fs = sink(mysignal)\n\nKeyword arguments\n\nFrame Rate\n\nThe frame rate does not need to be specified, it will use either the frame rate of signal or a default frame rate (which raises a warning). If specified, the given frame rate is passed to signal when coercing the input to a signal.\n\nDuration\n\nYou can limit the output of the given signal to the specified duration. If this duration exceedes the duration of the passed signal an error will be thrown.\n\nValues for to\n\nType\n\nIf to is a type (e.g. Array) the signal is written to a value of that type.\n\n\n\n\n\nFilename\n\nIf to is a string, it is assumed to describe the name of a file to which the signal will be written. You will need to call import or using on an appropriate backend for writing to the given file type.\n\nAvailable backends include the following pacakges\n\nWAV\nLibSndFile\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink!","page":"Reference","title":"SignalOperators.sink!","text":"sink!(array,x;[framerate])\n\nWrite size(array,1) frames of signal x to array. If no frame rate has been specified for x you can specify it now, using framerate (it will default to 44.1kHz).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Inspection-1","page":"Reference","title":"Signal Inspection","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"inflen\nduration\nnframes\nnchannels\nframerate\nchannel_eltype","category":"page"},{"location":"reference/#SignalOperators.inflen","page":"Reference","title":"SignalOperators.inflen","text":"inflen\n\nRepresents an infinite length. Proper overloads are defined to handle arithmetic and ordering for the infinite value.\n\nMissing values\n\nFor the purposes of SignalOperators missing values are considered to be unknown, but of finite length. For example: inflen * missing == inflen.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SignalOperators.duration","page":"Reference","title":"SignalOperators.duration","text":"duration(x)\n\nReturn the duration of the signal in seconds, if known. May return missing or inflen. The value missing always denotes a finite but unknown length.\n\nnote: Note\nIf your are implementing a custom signal, you need not normally define duration as it will be computed from nframes and framerate. However, if one or both of these is missing and you want duartion to return a non-missing value, you can define custom method of duration.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nframes","page":"Reference","title":"SignalOperators.nframes","text":"nframes(x)\n\nReturns the number of frames in the signal, if known. May return missing or inflen. The value missing always denotes a finite but unknown length.\n\nnote: Note\nThe return value of nframes for a block (see custom signals must be a non-missing, finite value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nchannels","page":"Reference","title":"SignalOperators.nchannels","text":"nchannels(x)\n\nReturns the number of channels in the signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.framerate","page":"Reference","title":"SignalOperators.framerate","text":"framerate(x)\n\nReturns the frame rate of the signal (in Hertz). May return missing if the frame rate is unknown.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.channel_eltype","page":"Reference","title":"SignalOperators.channel_eltype","text":"channel_eltype(x)\n\nReturns the element type of an individual channel of a signal (e.g. Float64).\n\nnote: Note\nchannel_eltype and eltype are, in most cases, the same, but not necesarilly so.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Reformatting-1","page":"Reference","title":"Signal Reformatting","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"toframerate\ntochannels\ntoeltype\nformat\nuniform","category":"page"},{"location":"reference/#SignalOperators.toframerate","page":"Reference","title":"SignalOperators.toframerate","text":"toframerate(x,fs;blocksize)\n\nChange the frame rate of x to the given frame rate fs. The underlying implementation depends on whether the input is a computed or data signal, as determined by EvalTrait.\n\nComputed signals (e.g. signal(sin)) are resampled exactly: the result is simply computed for more time points or fewer time points, so as to generate the appropriate number of frames.\n\nData-based signals (signal(rand(50,2))) are resampled using filtering (akin to DSP.resample). In this case you can use the keyword arugment blocksize to change the analysis window used. See filtersignal for more details. Setting blocksize for a computed signal will succeed, but different blocksize values have no effect on the underlying implementation.\n\nImplementation\n\nYou need only implement this function for custom signals for particular scenarios, described below.\n\nCustom Computed Signals\n\nIf you implement a new sigal type that is a computed signal, you must implement toframerate with the following type signature.\n\n\nfunction toframerate(x::MyCustomSignal,s::IsSignal{<:Any,<:Number},\n    c::ComputedSignal,framerate;blocksize)\n\n    ## ...\nend\n\nThe result should be a new version of the computed signal with the given frame rate.\n\nHandling missing frame rates\n\nIf you implement a new signal type that can handle missing frame rate values, you will need to implement the following version of toframerate so that a known frame rate can be applied to a signal with a missing frame rate.\n\n\nfunction toframerate(x::MyCustomSignal,s::IsSignal{<:Any,Missing},\n    evaltrait,framerate;blocksize)\n\n    ## ...\nend\n\nThe result should be a new version of the signal with the specified frame rate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.tochannels","page":"Reference","title":"SignalOperators.tochannels","text":"tochannels(x,ch)\n\nForce a signal to have ch number of channels, by mixing channels together or broadcasting a single channel over multiple channels.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.toeltype","page":"Reference","title":"SignalOperators.toeltype","text":"toeltype(x,T)\n\nConverts individual frames in signal x to type T.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.format","page":"Reference","title":"SignalOperators.format","text":"format(x,fs,ch)\n\nEfficiently convert both the framerate (fs) and channels ch of signal x. This selects an optimal ordering for toframerate and tochannels to avoid redundant computations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.uniform","page":"Reference","title":"SignalOperators.uniform","text":"uniform(xs;channels=false)\n\nPromote the frame rate (and optionally the number of channels) to be the highest frame rate (and optionally highest channel count) of the iterable of signals xs.\n\nnote: Note\nuniform rarely needs to be called directly. It is called implicitly on all passed signals, within the body of operators such as mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Operators-1","page":"Reference","title":"Signal Operators","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"until\nafter\nappend\nprepend\npad\nmirror\ncycle\nlastframe\nSignalOperators.valuefunction\nfiltersignal\nlowpass\nhighpass\nbandpass\nbandstop\nnormpower\nmapsignal\nmix\namplify\naddchannel\nchannel\nrampon\nrampoff\nramp\nfadeto","category":"page"},{"location":"reference/#SignalOperators.until","page":"Reference","title":"SignalOperators.until","text":"until(x,time)\n\nCreate a signal of all frames of x up until and including time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.after","page":"Reference","title":"SignalOperators.after","text":"after(x,time)\n\nCreate a signal of all frames of x after time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.append","page":"Reference","title":"SignalOperators.append","text":"append(x,y,...)\n\nAppend a series of signals, one after the other.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.prepend","page":"Reference","title":"SignalOperators.prepend","text":"prepend(x,y,...)\n\nPrepend the series of signals: prepend(xs...) is equivalent to append(reverse(xs)...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.pad","page":"Reference","title":"SignalOperators.pad","text":"pad(x,padding)\n\nCreate a signal that appends an infinite number of values, padding, to x. The value padding can be:\n\na number\na tuple or vector\na type function: a one argument function of the channel_eltype of x\na value function: a one argument function of the signal x for which   SignalOperators.valuefunction(padding) == true.\nan indexing function: a three argument function following the same type signature as getindex for two dimensional arrays.\n\nIf the signal is already infinitely long (e.g. a previoulsy padded signal), pad has no effect.\n\nIf padding is a number it is used as the value for all frames and channels past the end of x.\n\nIf padding is a tuple or vector it is the value for all frames past the end of x.\n\nIf padding is a type function it is passed the channel_eltype of the signal and the resulting value is used as the value for all frames past the end of x. Examples include zero and one\n\nIf padding is a value function it is passed x just before padding during sink begins and it should return a tuple of channel_eltype(x) values. This value is repeated for the remaining frames. It is generally only useful when x is an AbstractArray.\n\nIf padding is an indexing function (it accepts 3 arguments) it will be used to retrieve frames from the signal x assuming it conforms to the AbstractArray interface, with the first index being frames and the second channels. If the frame index goes past the bounds of the array, it should be transformed to an index within the range of that array. Note that such padding functions only work on signals that are also AbstractArray objects. You can always generate an array from a given signal by first passing it through sink or sink!.\n\nSee also\n\ncycle mirror lastframe valuefunction\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mirror","page":"Reference","title":"SignalOperators.mirror","text":"mirror(x,i,j)\n\nAn indexing function which mirrors the indices when i > size(x,1). This means that past the end of the signal x, the signal first repeats with frames in reverse order, then repeats in the original order, so on and so forth. It can be passed as the second argument to  pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.cycle","page":"Reference","title":"SignalOperators.cycle","text":"cycle(x,i,j)\n\nAn indexing function which wraps index i using mod, thus repeating the signal when i > size(x,1). It can be passed as the second argument to pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.lastframe","page":"Reference","title":"SignalOperators.lastframe","text":"lastframe\n\nWhen passed as an argument to pad, allows padding using the last frame of a signal. You cannot use this function in other contexts, and it will normally throw an error. See pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.valuefunction","page":"Reference","title":"SignalOperators.valuefunction","text":"SignalOperators.valuefunction(fn)\n\nReturns true if fn should be treated as a value function. See pad. If you wish your own function to be a value function, you can do this as follows.\n\nSignalOperators.valuefunction(::typeof(myfun)) = true\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.filtersignal","page":"Reference","title":"SignalOperators.filtersignal","text":"filtersignal(x,h;[blocksize])\n\nApply the given filter h (from DSP) to signal x.\n\nBlocksize\n\nBlocksize determines the size of the buffer used when computing intermediate values of the filter. It defaults to 4096. It need not normally be adjusted.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.lowpass","page":"Reference","title":"SignalOperators.lowpass","text":"lowpass(x,low;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a lowpass filter to x at the given cutoff frequency (low). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.highpass","page":"Reference","title":"SignalOperators.highpass","text":"highpass(x,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a highpass filter to x at the given cutoff frequency (low). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandpass","page":"Reference","title":"SignalOperators.bandpass","text":"bandpass(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandpass filter to x at the given cutoff frequencies (low and high). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandstop","page":"Reference","title":"SignalOperators.bandstop","text":"bandstop(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandstop filter to x at the given cutoff frequencies (low and high). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.normpower","page":"Reference","title":"SignalOperators.normpower","text":"normpower(x)\n\nReturn a signal with normalized power. That is, divide all frames by the root-mean-squared value of the entire signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mapsignal","page":"Reference","title":"SignalOperators.mapsignal","text":"mapsignal(fn,arguments...;padding,bychannel)\n\nApply fn across the frames of arguments, producing a signal of the output of fn. Shorter signals are padded to accommodate the longest finite-length signal. The function fn should treat each argument as a single number and return a single number. This operation is broadcast across all channels of the input. It is expected to be a type stable function.\n\nNormally the signals are first promoted to have the same samle rate and the same number of channels using uniform (with channels=true).\n\nCross-channel functions\n\nThe function fn is normally broadcast across channels, but if you wish to treat each channel separately you can set bychannel=false. In this case the inputs to fn will be indexable objects (tuples or arrays) of all channel values for a given frame, and fn should return a type-stable tuple value (for a multi-channel or single-channel result) or a number (for a single-channel result only). For example, the following would swap the left and right channels.\n\nx = rand(10,2)\nswapped = mapsignal(x,bychannel=false) do val\n    val[2],val[1]\nend\n\nWhen bychannel=false the channels of each signal are not promoted:\n\nPadding\n\nPadding determines how frames past the end of shorter signals are reported. The value of padding is passd to pad. Its default value is determined by the value of fn. The default value for the four basic arithmetic operators is their identity (one for * and zero for +). These defaults are set on the basis of fn using default_pad(fn). A fallback implementation of default_pad returns zero.\n\nTo define a new default for a specific function, just create a new method of default_pad(fn)\n\n\nmyfun(x) = 2x + 3\nSignalOperators.default_pad(::typeof(myfun)) = one\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mix","page":"Reference","title":"SignalOperators.mix","text":"mix(xs...)\n\nSum all signals together, using mapsignal\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.amplify","page":"Reference","title":"SignalOperators.amplify","text":"amplify(xs...)\n\nFind the product, on a per-frame basis, for all signals xs using mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.addchannel","page":"Reference","title":"SignalOperators.addchannel","text":"addchannel(xs...)\n\nConcatenate the channels of all signals into one signal, using mapsignal. This will result in a signal with sum(nchannels,xs) channels.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.channel","page":"Reference","title":"SignalOperators.channel","text":"channel(x,n)\n\nSelect channel n of signal x, as a single-channel signal, using mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampon","page":"Reference","title":"SignalOperators.rampon","text":"rampon(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampoff","page":"Reference","title":"SignalOperators.rampoff","text":"rampoff(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the offset of a signal, smoothly transitioning from full amplitude to 0 amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ramp","page":"Reference","title":"SignalOperators.ramp","text":"ramp(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset and offset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds at the start and from full to 0 amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.fadeto","page":"Reference","title":"SignalOperators.fadeto","text":"fadeto(x,y,[len=10ms],[fn=x->sinpi(0.5x)])\n\nAppend x to y, with a smooth transition lasting len seconds fading from x to y (so the total length is duration(x) + duration(y) - len).\n\nThis fade is accomplished with a rampoff of x and a rampon for y. fn should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Custom-Signals-1","page":"Reference","title":"Custom Signals","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"SignalOperators.SignalTrait\nSignalOperators.IsSignal\nSignalOperators.EvalTrait\nSignalOperators.nextblock\nSignalOperators.frame\nSignalOperators.timeslice\nSignalOperators.ArrayBlock","category":"page"},{"location":"reference/#SignalOperators.SignalTrait","page":"Reference","title":"SignalOperators.SignalTrait","text":"SiganlOperators.SignalTrait(::Type{T}) where T\n\nReturns either nothing if the type T should not be considered a signal (the default) or IsSignal to indicate the signal format for this signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.IsSignal","page":"Reference","title":"SignalOperators.IsSignal","text":"SignalOperators.IsSignal{T,Fs,L}\n\nRepresents the format of a signal type with three type parameters:\n\nT - The channel_eltype of the signal.\nFs - The type of the framerate. It should be either Float64 or   Missing.\nL - The type of the length of the signal. It should be either\n\nInfiniteLength, Missing or Int.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SignalOperators.EvalTrait","page":"Reference","title":"SignalOperators.EvalTrait","text":"SiganlOperators.EvalTrait(x)\n\nIndicates whether the signal is a DataSignal or ComputedSignal. Data signals represent frames concretely as a set of frames. Examples include arrays and numbers. Data signals generally return themselves, or some wrapper type when sink is called on them. Computed signals are any signal that invovles some intermediate computation, in which frames must be computued on the fly. Calls to sink on a computed signal results in some new, data signal. Most signals returned by a signal operator are computed signals.\n\nComputed signals have the extra responsibility of implementing toframerate\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nextblock","page":"Reference","title":"SignalOperators.nextblock","text":"SignalOperators.nextblock(x,maxlength,skip,[block])\n\nRetrieve the next block of frames for signal x. The final, fourth argument is optional. If it is left out, nextblock returns the first block of the signal. The resulting block must has no more than maxlength frames, but may have fewer frames than that; it should not have zero frames unless maxlength == 0. If skip == true, it is guaranted that frame will never be called on the returned block. The value of skip is true, for example, when skipping blocks during a call to after).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.frame","page":"Reference","title":"SignalOperators.frame","text":"SignalOperators.frame(x,block,i)\n\nRetrieves the frame at index i of the given block of signal x. A frame is one or more channels of channel_eltype(x) values. The return value should be an indexable object (e.g. a number, tuple or array) of these channel values. This method should be implemented by blocks of custom signals.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.timeslice","page":"Reference","title":"SignalOperators.timeslice","text":"SignalOperators.timeslice(x::AbstractArray,indices)\n\nExtract the slice of x with the given time indices.\n\nCustom signals can implement this method if the signal is an AbstractArray allowing the use of a fallback implementation of SignalOperators.nextblock.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ArrayBlock","page":"Reference","title":"SignalOperators.ArrayBlock","text":"ArrayBlock{A,S}(data::A,state::S)\n\nA straightforward implementation of blocks as an array and a custom state. The array allows a generic implementation of nframes and SignalOperators.frame. The fields of this struct are data and state.\n\nCustom signals can return an ArrayBlock from SignalOperators.nextblock to allow for fallback implementations of nframes and SignalOperators.frame.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Custom-Sinks-1","page":"Reference","title":"Custom Sinks","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"SignalOperators.initsink\nSignalOperators.sink_helper!","category":"page"},{"location":"reference/#SignalOperators.initsink","page":"Reference","title":"SignalOperators.initsink","text":"SignalOperators.initsink(x,::Type{T},len)\n\nInitialize an object of type T so that it can store the first len frames of signal x.\n\nIf you wish an object to serve as a custom sink you can implement this method. You should probably use nchannels and channel_eltype of x to determine how to initialize the object.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink_helper!","page":"Reference","title":"SignalOperators.sink_helper!","text":"SignalOperators.sink_helper!(result,written,x,block)\n\nWrite the given block of frames from signal x to result given that a total of written frames have already been written to the result.\n\nThis method should be fast: i.e. a for loop using @simd and @inbounds. It should call nframes and SignalOperators.frame on the block to write the frames. Do not call frame more than once for each index of the block.\n\n\n\n\n\n","category":"function"},{"location":"reference/#","page":"Reference","title":"Reference","text":"```","category":"page"},{"location":"custom_signal/#custom_signals-1","page":"Custom Signals","title":"Custom Signals","text":"","category":"section"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"Many signals can be readily created by passing a function to signal or by using mapsignal. However, in some cases it may be preferable to define a new signal type entirely. This allows for the most flexibility in terms of how the signal will behave within a chain of signal operators.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"To be propperly treated as a signal, an object must return an appropriate SignalOperators.IsSignal object when calling SignalOperators.SignalTrait.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"Any object returning SignalOperators.IsSignal should implement SignalOperators.nextblock, which is used to sequentially retrieve blocks from a signal. If your custom signal is an AbstractArray there is a fallback implementaiton of SignalOperators.nextblock which only requires you to implement SignalOperators.timeslice","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"Analogous to Base.iterate, SignalOperators.nextblock will return nothing when there are no more blocks to produce. The blocks returned by SignalOperators.nextblock must implement the following two methods.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"nframes Like a signal, each block has a fixed number of frames. Unlike signals, this cannot be an infinite or missing value. It should be a fast, type-stable function.\nSignalOperators.frame Individual frames of the block can be accessed by their index within the block (falling in the range of 1:nframes(block)). This should be a fast, type-stable function. The method is guaranteed to only be called at most once for each index in the block. Normally, you should annotate it with @Base.propagate_inbounds just as you would an implementation of Baes.getindex.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"If you intend to simply returns blocks using arrays of data you can use SignalOperators.ArrayBlock, which will implement nframes and frame for you.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"The custom signal will also need to implement methods for the following, signal-inspection methods.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"nframes - to indicate how many frames are present in the signal;","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"this may be an infinite or missing value.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"framerate - to indicate the sampling rate of the signal\nnchannels - to indicate how many channels per frame there are in this signal","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"Finally, there are several optional methods you can define for signals as well.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"signal - to enable one more other types to be interpreted as your","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"custom signal type.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"duration - to allow missing values for nframes and non-missing values for duration.\nSignalOperators.EvalTrait and toframerate - to enable custom handling of","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"signal resmapling.","category":"page"},{"location":"#SignalOperators.jl-1","page":"Home","title":"SignalOperators.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SignalOperators is a Julia package that aims to provide a clean interface for generating and manipulating signals: typically sounds, but any signal regularly sampled in time can be manipulated.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can install it in Julia by starting the Pkg prompt (hit ]), and using the add command.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(1.2) pkg> add SignalOperators","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As a preview of functionality, here are some example sound generation routines. You can find more detailed information in the manual and reference.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using SignalOperators\nusing SignalOperators.Units # allows the use of dB, Hz, s etc... as unitful values\n\n# a pure tone 20 dB below a power 1 signal, with on and off ramps (for\n# a smooth onset/offset)\nsound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)\n\n# a sound defined by a file, matching the overall power to that of sound1\nsound2 = \"example.wav\" |> normpower |> amplify(-20dB)\n\n# a 1kHz sawtooth wave\nsound3 = signal(ϕ -> ϕ-π,ω=1kHz) |> ramp |> normpower |> amplify(-20dB)\n\n# a 5 Hz amplitude modulated noise\nsound4 = randn |>\n    amplify(signal(ϕ -> 0.5sin(ϕ) + 0.5,ω=5Hz)) |>\n    until(5s) |> normpower |> amplify(-20dB)\n\n# a 1kHz tone surrounded by a notch noise\nSNR = 5dB\nx = signal(sin,ω=1kHz) |> until(1s) |> ramp |> normpower |> amplify(-20dB + SNR)\ny = signal(randn) |> until(1s) |> bandstop(0.5kHz,2kHz) |> normpower |>\n  amplify(-20dB)\nscene = mix(x,y)\n\n# write all of the signals to a single file, at 44.1 kHz\nappend(sound1,sound2,sound3,sound4,scene) |> toframerate(44.1kHz) |> sink(\"examples.wav\")\n","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many thanks to @ssfrr for some great discussions during this PR, and related issues on the SampledSignals package. Those interactions definitely influenced my final design here.","category":"page"}]
}
