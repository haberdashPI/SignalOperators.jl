var documenterSearchIndex = {"docs":
[{"location":"manual/#","page":"Manual","title":"Manual","text":"SignalOperators is a package that aims to provide a clean interface for generating and manipulating regularly sampled signals, typically sounds. ","category":"page"},{"location":"manual/#Key-concepts-1","page":"Manual","title":"Key concepts","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several important concepts employed across the public interface. Let's step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"This example creates a 1 kHz pure-tone (sine wave) that lasts 5 serconds. It's amplitude is 20 dB lower than a signal with unit 1 power. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are a few things going on here: piping, the use of units, infinite length signals, and unspecified sample rates ","category":"page"},{"location":"manual/#Piping-1","page":"Manual","title":"Piping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"All of the functions implemented in SignalOperators can be piped. This means that instead of passing the first argument to a signal operator, you can pipe it using |>. For example, the two statements below have the same meaning. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s)\nsound1 = until(signal(sin,ω=1kHz),5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The use of piping makes it easier to read the sequence of operations that are performed on the signal.","category":"page"},{"location":"manual/#Units-1","page":"Manual","title":"Units","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In any place where a signal operator needs a time or a frequency, it can be specified using units. If units are not specified, time is assumed to be in seconds, and frequency in Hertz. So, for example, the following two statements are equivalent. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz)\nsound1 = signal(sin,ω=1000)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants you must call using SignalOperators.Units. The units defined are samples, Hz, s kHz ms °, rad and dB. You can just include the ones you want using e.g. using SignalOperators.Units: Hz, or you can include more by adding the Unitful package to your project and adding the desired units from there. The samples unit is unique to the SignalOperators package and allows you to specify the units of time in terms of the number of samples rather than units of time. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Note that the output of all functions to inspect a signal (e.g. duration, samplerate) are Float64 values in the default unit (seconds or Hertz).","category":"page"},{"location":"manual/#decibels-1","page":"Manual","title":"decibels","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can pass an amplification value as unitless or a unitful value in dB, a unitless value is not assumed to be in decibels. Instead it's assumed to be the actual ratio by which you wish to multiply the signal. E.g. amplify(x,2) will make x twice as loud. ","category":"page"},{"location":"manual/#Infinite-lengths-1","page":"Manual","title":"Infinite lengths","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Some of the ways you can define a signal lead to an infinite length signal. You cannot store an infinite signal. It is represented as a function of some kind. Operations on signals are generally lazy, meaning the samples of the signal aren't evaluated until necessary. To allow actual data to be created from a signal, you have to specify the length, using until. For example, when using signal(sin), the signal is an infinite length sine wave. That's why, in the example above we use until to specify the length, like so: ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> until(5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Infinite lengths are represented as the value inflen. This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc... ","category":"page"},{"location":"manual/#Unspecified-sample-rates-1","page":"Manual","title":"Unspecified sample rates","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You may notice that the above signal has no defined sample rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined sample rate, the unspecified sample rate will be resolved to that same rate (see Signal promotion, below). If there is no defined sample rate by the time you call sink you can specify it then. ## Sinking","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Once you have defined a signal, you can create some concrete sequence of samples from it. This is done using sink. The resulting value is itself a signal, so you can pass this to other signal operators. The function sink is also used to create a file. Sink must consume a finite-length signal. To store the five second signal in the above example to \"example.wav\" we could write the following.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 |> sink(\"example.wav\",samplerate=44.1kHz)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In this case, since sound1 had no defined sample rate, we have to tell sink what the sample rate is. If the signal already had a sample rate defined, we could just call sink(\"example.wav\"). ","category":"page"},{"location":"manual/#Signal-promotion-1","page":"Manual","title":"Signal promotion","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A final concept, which may not be as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different element type (e.g. Float32 vs Float64), different number of channels, or different sample rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don't have to worry about the specific format of the signal, and you won't loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using tochannels or tosamplerate). ","category":"page"},{"location":"manual/#Signal-generation-1","page":"Manual","title":"Signal generation","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are three basic types that can be interpreted as signals: numbers, arrays and functions. Internally the function signal is called on any object passed to a signal operator, you can call this function yourself if you want to specify the exact sample rate by which you want to interpret the signal. ","category":"page"},{"location":"manual/#Numbers-1","page":"Manual","title":"Numbers","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A number is treated as an infinite length signal, with unknown sample rate. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"1 |> until(1s) |> sink(samplerate=10Hz) == ones(10)","category":"page"},{"location":"manual/#Arrays-1","page":"Manual","title":"Arrays","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A standard array is treated as a finite signal, with unknown sample rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"rand(10,2) |> sink(samplerate=10Hz) |> duration == 1","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An AxisArray is treated as a finite signal with a known sample rate (and is the default output of sink) ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using AxisArrays\nx = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))\nsamplerate(x) == 10","category":"page"},{"location":"manual/#Functions-1","page":"Manual","title":"Functions","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A function is can be treated as an infinite signal. It should take a single argument which is the time in radians (not seconds). Radians are used to make defining the frequency of the signal for typical functions (e.g. sin), which is defind using the keywored argument ω or frequency. See signal's documentation for more detail's.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> duration |> isinf == true","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An exception to this is randn. It can be used directly as a signal with unknown sample rate. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"randn |> duration == isinf","category":"page"},{"location":"manual/#Signal-inspection-1","page":"Manual","title":"Signal inspection","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can examine the properties of a signal using nsamples, nchannels, samplerate, and duration.","category":"page"},{"location":"manual/#Signal-manipulation-1","page":"Manual","title":"Signal manipulation","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several categories of signal manipulation: extending, cutting, filtering, ramping, and mapping.","category":"page"},{"location":"manual/#Extending-1","page":"Manual","title":"Extending","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can extend a signal using pad or append. A padded signal becomes infinite and ends with the specified value, usually one or zero. You can append to or more signals (or preprend) so the occur one after another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"pad(x,zero) |> duration |> isinf == true\nappend(x,y) |> duration == duration(x) + duration(y)","category":"page"},{"location":"manual/#Cutting-1","page":"Manual","title":"Cutting","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can cut signals apart, removing either the end of the signal (until) or the beginning (after). The operations are exact compliments of one another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"append(until(x,2s),after(x,2s)) |> nsamples == nsamples(x)","category":"page"},{"location":"manual/#Filtering-1","page":"Manual","title":"Filtering","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can filter signals, removing undesired frequencies using lowpass, highpass, bandpass, bandstop and filtersignal. The latter allows the use of any arbitrary filter defined using DSP. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(randn) |> lowpass(20Hz)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Note that if you use using DSP you will have to also call dB = SignalOperators.Units.dB if you want to make use of the proper meaning of dB for SignalOperators: DSP also defined a value for dB.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A unusual filter is normpower: it computes the root mean squared power of the signal and then normalizes each sample by that value.","category":"page"},{"location":"manual/#Ramping-1","page":"Manual","title":"Ramping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A ramp allows for smooth transition from 0 amplitude to the full amplitude of the signal. It is useful for avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=2kHz) |> until(5s) |> ramp","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can ramp only the start of a signal (rampon), or the end of it (rampoff) and you can use ramps to create a smooth transition between two signals (fadeto). ","category":"page"},{"location":"manual/#Mapping-1","page":"Manual","title":"Mapping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Probably the most powerful operator is mapsignal. It works a lot like map but automatically promotes the signals, as with all operators, and it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest finite-length signal.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a = signal(sin,ω=2kHz) |> until(2s)\nb = signal(sin,ω=1kHz) |> until(3s)\na_minus_b = mapsignal(-,a,b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The function mapsignal cannot, itself be piped, due to ambigity in the arugments, but shortcuts for this function have been provided for addition mix] and multiplication amplify], the two most common operations, and these two shortcuts have piped versions available.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a_plus_b = mix(a,b)\na_times_b = amplify(a,b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can add or select out channels using addchannel and channel, which are defined in terms of calls to mapsignal. These use a variant of mapsignal where the keyword across_channels is defined as true (see mapsignal's documentation for details).","category":"page"},{"location":"reference/#Signal-Generation-1","page":"Reference","title":"Signal Generation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"signal\nsink\nsink!","category":"page"},{"location":"reference/#SignalOperators.signal","page":"Reference","title":"SignalOperators.signal","text":"signal(x,[samplerate])\n\nCoerce x to be a signal, optionally specifying its sample rate (usually in Hz). Signal operations first coerce their arguments to be a signal so this needs only to be specified when the additional arguments to signal are needed.\n\nnote: Note\nIf you pipe signal (e.g. myobject |> signal(2kHz)) you must specify the units of the sample rate. This is because a raw number is ambiguous, and could be interpreted as a signal (i.e. an infinite length signal of with constant valued samples).\n\nThe types of objects that can be coerced to signals are as follows.\n\n\n\n\n\nExisting signals\n\nAny existing signal just returns itself from signal. If a sample rate is specified it will be set if x has an unknown sample rate. If it has a known sample rate and doesn't match samplerate(x) and error will be throwns. If you want to change the sample rate of a signal use tosamplerate.\n\n\n\n\n\nNumbers\n\nNumbers can be treated as infinite length, constant signals of unknown sample rate.\n\n\n\n\n\nArrays\n\nArrays can be treated as signals. The first dimension is time, the second channels. \n\nAxisArrays, if they have an axis labled time and one or zero additioanl axes, can be treated as a signal. The time dimension must be represted using a Range.\n\n\n\n\n\nFunctions\n\nsignal(fn,[samplerate];[ω/frequency],[ϕ/phase])\n\nFunctions can define infinite length signals of known or unknown sample rate. The function fn can either return a number. Or, if you wish to specify a multi-channel signal, a tuple of values.\n\nThe input to fn is either a phase value or a time value. If passed a frequency (using either the ω or frequency keyword), the input to fn will be a phase value in radians, ranging from 0 to 2π. If no frequency is specified the value passed to f is the total time in seconds. Specifying phase (by the ϕ or phase keyword) will first add that value to the input. The phase is assumed to be in units of radians (but you can also pass degrees by using °).\n\n\n\n\n\nIf fn == randn no frequency or phase can be specified. Instead there is a signle keywored argument rng which allows you to specify the random number generator, which defaults to Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink","page":"Reference","title":"SignalOperators.sink","text":"sink([signal],[to=AxisArray];length,samplerate)\n\nCreates a given type of object (to) from a signal. By default it is an AxisArray with time as the rows and channels as the columns. If a filename is specified for to, the signal is written to the given file. If given a type (e.g. Array) the signal is written to that type. The sample rate does not need to be specified, it will use either the sample rate of signal or a default sample rate (which raises a warning). \n\nYou can specify a length or samplerate for the signal when calling sink if it has yet to be defined.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Inspection-1","page":"Reference","title":"Signal Inspection","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"inflen\nduration\nnsamples\nnchannels\nsamplerate","category":"page"},{"location":"reference/#SignalOperators.duration","page":"Reference","title":"SignalOperators.duration","text":"duration(x)\n\nReturn the duration of the signal in seconds, if known. May return missing or inflen. The value missing always denotes a finite, but unknown length.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nsamples","page":"Reference","title":"SignalOperators.nsamples","text":"nsamples(x)\n\nReturns the number of samples in the signal, if known. May return missing or inflen. The value missing always denotes a finite, but unknown length.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nchannels","page":"Reference","title":"SignalOperators.nchannels","text":"nchannels(x)\n\nReturns the number of channels in the signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.samplerate","page":"Reference","title":"SignalOperators.samplerate","text":"samplerate(x)\n\nReturns the sample rate of the signal (in Hz). May return missing if the  sample rate is unknown.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Manipulation-1","page":"Reference","title":"Signal Manipulation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"until\nafter\nappend\nprepend\npad\nfiltersignal\nlowpass\nhighpass\nbandpass\nbandstop\nnormpower\nmapsignal\nmix\namplify\naddchannel\nchannel\nrampon\nrampoff\nramp\nfadeto","category":"page"},{"location":"reference/#SignalOperators.until","page":"Reference","title":"SignalOperators.until","text":"until(x,time)\n\nCreate a signal of all samples of x up until time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.after","page":"Reference","title":"SignalOperators.after","text":"after(x,time)\n\nCreate a signal of all samples of x after time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.append","page":"Reference","title":"SignalOperators.append","text":"append(x,y,rest...)\n\nAppend a series of signals, one after the other.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.prepend","page":"Reference","title":"SignalOperators.prepend","text":"prepend(xs...)\n\nPrepend the series of signals: prepend(xs...) = append(reverse(xs)...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.pad","page":"Reference","title":"SignalOperators.pad","text":"pad(x,padding)\n\nCreate a signal that appends an infinite number of values, padding, to x. The value padding can be a number or a function of a type (e.g. zero).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.filtersignal","page":"Reference","title":"SignalOperators.filtersignal","text":"filtersignal(x,h;[blocksize])\n\nApply the given filter h (from DSP) to signal x. \n\nBlocksize\n\nBlocksize determines the size of the buffer used when computing intermediate values of the filter. It defaults to 4096. It need not normally be adjusted.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.lowpass","page":"Reference","title":"SignalOperators.lowpass","text":"lowpass(x,low;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a lowpass filter to x at the given cutoff frequency (low).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.highpass","page":"Reference","title":"SignalOperators.highpass","text":"highpass(x,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a highpass filter to x at the given cutoff frequency (low).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandpass","page":"Reference","title":"SignalOperators.bandpass","text":"bandpass(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandpass filter to x at the given cutoff frequencies (low and high).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandstop","page":"Reference","title":"SignalOperators.bandstop","text":"bandstop(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandstop filter to x at the given cutoff frequencies (low and high).  See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.normpower","page":"Reference","title":"SignalOperators.normpower","text":"normpower(x)\n\nDivide all samples by the root-mean-squared value of the signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mapsignal","page":"Reference","title":"SignalOperators.mapsignal","text":"mapsignal(fn,arguments...;padding,across_channels)\n\nApply fn across the samples of arguments, producing a signal of the output of fn. Shorter signals are padded to accomodate the longest finite-length signal. The function fn can return a single number or a tuple of numbers. In either case it is expected to be a type stable function.\n\nCross-channel functions\n\nThe function is normally broadcast across channels, but if you wish to treat each channel seperately you can set across_channels=true. In the case the inputs to fn will be tuples of all channel values for a given sample.\n\nPadding\n\nPadding determines how samples past the end of shorter signals are reported, it is set to a default specific fn using default_pad(fn). There is a fallback implementation which returns zero. You can pass a number or a function of a type (e.g. zero) to padding. The default for the four basic arithematic operators is their identity (one for * and zero for +).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mix","page":"Reference","title":"SignalOperators.mix","text":"mix(xs...)\n\nSum all signals together, using mapsignal\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.amplify","page":"Reference","title":"SignalOperators.amplify","text":"amplify(xs...)\n\nMultipy all signals by one another, using mapsignal\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.addchannel","page":"Reference","title":"SignalOperators.addchannel","text":"addchannel(xs...)\n\nConcatenate the channels of all signals into one signal with sum(nchannels,xs) channels.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.channel","page":"Reference","title":"SignalOperators.channel","text":"channel(x,n)\n\nSelect channel n of signal x, as a single channel signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reformatting-1","page":"Reference","title":"Reformatting","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"tosamplerate\ntochannels\nformat\nuniform","category":"page"},{"location":"#SignalOperators.jl-1","page":"Home","title":"SignalOperators.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SignalOperators is a Julia package that aims to provide a clean interface for generating and manipulating signals: typically sounds, but any signal regularly sampled in time could be manipulated.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can install it in Julia by starting the Pkg prompt (hit ]), and using the add command.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(1.2) pkg> add SignalOperators","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As a preview of functionality, here are some example sound generation routines. You can find more detailed information in the manual and reference.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using SignalOperators\nusing SignalOperators.Units # allows the use of dB, Hz, s etc... as unitful values\n\n# a pure tone 20 dB below a power 1 signal, with on and off ramps (for\n# a smooth onset/offset)\nsound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)\n\n# a sound defined by a file, matching the overall power to that of sound1\nsound2 = \"example.wav\" |> normpower |> amplify(-20dB)\n\n# a 1kHz sawtooth wave \nsound3 = signal(ϕ -> ϕ/π - 1,ω=1kHz) |> ramp |> normpower |> amplify(-20dB)\n\n# a 5 Hz amplitude modulated noise\nsound4 = randn |> \n    amplify(signal(ϕ -> 0.5sin(ϕ) + 0.5,ω=5Hz)) |> \n    until(5s) |> normpower |> amplify(-20dB)\n\n# a 1kHz tone surrounded by a notch noise\nSNR = 5dB\nx = signal(sin,ω=1kHz) |> until(1s) |> ramp |> normpower |> amplify(-20dB + SNR)\ny = signal(randn) |> until(1s) |> bandstop(0.5kHz,2kHz) |> normpower |>\n  amplify(-20dB)\nscene = mix(x,y)\n\n# write all of the signal to a single file, at 44.1 kHz\nappend(sound1,sound2,sound3,sound4,scene) |> tosamplerate(44.1kHz) |> sink(\"examples.wav\")\n","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many thanks to @ssfrr for some great discussions during this PR, and related issues on the SampledSignals package. Those interactions definitely influenced my final design here.","category":"page"}]
}
