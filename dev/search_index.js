var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"SignalOperators is composed of a set of functions for generating, inspecting and operating over signals. Here, a \"signal\" is represented as a number of channels (e.g. left and right speaker) with values (e.g. Float64) sampled regularly in time (e.g. every 100th of a second, or 100 Hz).","category":"page"},{"location":"manual/#Key-concepts-1","page":"Manual","title":"Key concepts","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several important concepts employed across the public interface. Let's step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"This example creates a 1 kHz pure-tone (sine wave) that lasts 5 seconds. Its amplitude is 20 dB lower than a signal with unit 1 power.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are a few things going on here: piping, the use of units, infinite length signals, and unspecified sample rates.","category":"page"},{"location":"manual/#Piping-1","page":"Manual","title":"Piping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Almost all of the functions implemented in SignalOperators can be piped. This means that instead of passing the first argument to a function, you can pipe it using |>. For example, the two statements below have the same meaning.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz) |> until(5s)\nsound1 = until(signal(sin,ω=1kHz),5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The use of piping makes it easier to read the sequence of operations that are performed on the signal.","category":"page"},{"location":"manual/#Units-1","page":"Manual","title":"Units","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In any place where a function needs a time or a frequency, it can be specified in appropriate units. There are many places where units can be passed. They all have a default assumed unit, if a plain number without units is passed. The default units are seconds, Hertz, and radians as appropriate for the given argument.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = signal(sin,ω=1kHz)\nsound1 = signal(sin,ω=1000)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants, you must call using SignalOperators.Units. This exports the following units: samples, ksamples, Hz, kHz s, ms, rad, °, and dB. You can just include the ones you want using e.g. using SignalOperators.Units: Hz, or you can include more by adding the Unitful package to your project and adding the desired units from there. For example, using Unitful: MHz would include mega-Hertz frequencies (not usually useful for signals that are sounds). Most of the default units have been re-exported from Unitful. However, the samples unit and its derivatives (e.g. ksamples) are unique  to the SignalOperators package. They allow you to specify the time in terms of the number of samples: e.g. at a sample rate of 100 Hz, 2s == 200samples. Other powers of ten are represented for samples, (e.g. Msamples for mega-samples) but they are not exported (e.g. you would have to call SignalOperators.Units: Msamples before using 20Msamples).","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nYou can find the available powers-of-ten for units in Unitful.prefixdict","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Note that the output of functions to inspect a signal (e.g. duration, samplerate) are bare values in the default unit (e.g. seconds or Hertz). No unit is explicitly provided by the return value.","category":"page"},{"location":"manual/#Decibels-1","page":"Manual","title":"Decibels","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can pass an amplification value as a unitless or a unitful value in dB; a unitless value is not assumed to be in decibels. Instead, it's assumed to be the actual ratio by which you wish to multiply the signal. For example, amplify(x,2) will make x twice as loud.","category":"page"},{"location":"manual/#Infinite-lengths-1","page":"Manual","title":"Infinite lengths","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Some of the ways you can define a signal lead to an infinite length signal. You cannot store an infinite signal. It is represented as a function of some kind. Operations on signals are generally lazy, meaning the samples of the signal aren't computed until necessary. To allow actual data to be created from a signal, you have to specify the length, using until. For example, when using signal(sin), the signal is an infinite length sine wave. That's why, in the example above, we use until to specify the length, as follows.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> until(5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Infinite lengths are represented as the value inflen. This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc...","category":"page"},{"location":"manual/#Unspecified-sample-rates-1","page":"Manual","title":"Unspecified sample rates","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You may notice that the above signal has no defined sample rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined sample rate, the unspecified sample rate will be resolved to that same rate (see signal promotion, below). If there is no defined sample rate by the time you call sink, you can specify it then.","category":"page"},{"location":"manual/#Sinking-1","page":"Manual","title":"Sinking","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Once you have defined a signal, you can create some concrete sequence of samples from it. This is done using sink. When sink is simply passed a signal, the resulting value is itself a signal. This means you can continue to processes it with more operators. The function sink can also write data to a file. Sink must consume a finite-length signal. To store the five second signal in the above example to \"example.wav\" we could write the following.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 |> sink(\"example.wav\")","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In this case sound1 had no defined sample rate, so the default sample rate of 44.1khz will be used. The absence of an explicit sample rate will raise a warning.","category":"page"},{"location":"manual/#Signal-promotion-1","page":"Manual","title":"Signal promotion","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A final concept, which is not as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different number of channels or different sample rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don't have to worry about the specific format of the signal, and you won't loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using tochannels or tosamplerate).","category":"page"},{"location":"manual/#Signal-generation-1","page":"Manual","title":"Signal generation","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are four basic types that can be interpreted as signals: numbers, arrays, functions and files. Internally the function signal is called on any object passed to a function that inspects or operates on a signal; you can call signal yourself if you want to specify more information. For example, you may want to provide the exact sample rate the signal should be interpreted to have.","category":"page"},{"location":"manual/#Numbers-1","page":"Manual","title":"Numbers","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A number is treated as an infinite length signal, with unknown sample rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"1 |> until(1s) |> sink(samplerate=10Hz) == ones(10)","category":"page"},{"location":"manual/#Arrays-1","page":"Manual","title":"Arrays","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A standard array is treated as a finite signal with unknown sample rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"rand(10,2) |> sink(samplerate=10Hz) |> duration == 1","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An AxisArray or SampleBuf (form SampledSignals) is treated as a finite signal with a known sample rate (and is the default output of sink)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using AxisArrays\nx = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))\nsamplerate(x) == 10","category":"page"},{"location":"manual/#Functions-1","page":"Manual","title":"Functions","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A single argument function of time (in seconds) can be treated as an infinite signal. It can be also be a function of radians if you specify a frequency using ω (or frequency). See signal's documentation for more details.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=1kHz) |> duration |> isinf == true","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A small exception to this is randn. It can be used directly as a signal with unknown sample rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"randn |> duration == isinf","category":"page"},{"location":"manual/#Files-1","page":"Manual","title":"Files","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A file is interpreted as a WAV audio file to be loaded into memory. You must include the WAV package for this to work.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using WAV\nx = signal(\"example.wav\")","category":"page"},{"location":"manual/#Signal-inspection-1","page":"Manual","title":"Signal inspection","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can examine the properties of a signal using nsamples, nchannels, samplerate, and duration.","category":"page"},{"location":"manual/#Signal-operators-1","page":"Manual","title":"Signal operators","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several categories of signal operators: extending, cutting, filtering, ramping, and mapping.","category":"page"},{"location":"manual/#Extending-1","page":"Manual","title":"Extending","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can extend a signal using pad or append. A padded signal becomes infinite by appending the signal by a repeated value, usually one or zero. You can append two or more signals (or prepend) so they occur one after another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"pad(x,zero) |> duration |> isinf == true\nappend(x,y,z) |> duration == duration(x) + duration(y) + duration(z)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nYou cannot append more than one new signal within a pipe. That is, the following will throw an error.# Don't do this!\nx |> append(y,z)This is because append(y,z) does not return a function to be piped (as append(y) does). It returns a signal with y followed by z. You can instead call this as follows.# This will do what you want!\nx |> append(y) |> append(z)","category":"page"},{"location":"manual/#Cutting-1","page":"Manual","title":"Cutting","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can cut signals apart, removing either the end of the signal (until) or the beginning (after). The operations are exact compliments of one another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"append(until(x,2s),after(x,2s)) |> nsamples == nsamples(x)","category":"page"},{"location":"manual/#Filtering-1","page":"Manual","title":"Filtering","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can filter signals, removing undesired frequencies using lowpass, highpass, bandpass, bandstop and filtersignal. The latter allows the use of any arbitrary filter defined using DSP.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(randn) |> lowpass(20Hz)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"warning: Warning\nIf you write using DSP you will have to also write dB = SignalOperators.Units.dB if you want to make use of the proper meaning of dB for SignalOperators: DSP also defines dB.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An unusual filter is normpower: it computes the root mean squared power of the signal and then normalizes each sample by that value.","category":"page"},{"location":"manual/#Ramping-1","page":"Manual","title":"Ramping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A ramp allows for smooth transitions between 0 amplitude and the full amplitude of the signal. It is useful to avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"signal(sin,ω=2kHz) |> until(5s) |> ramp","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can ramp only the start of a signal (rampon), or the end of it (rampoff) and you can use ramps to create a smooth transition between two signals (fadeto).","category":"page"},{"location":"manual/#Mapping-1","page":"Manual","title":"Mapping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Probably the most powerful operator is mapsignal. It works a lot like map but automatically promotes the signals, as with all operators, and it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest finite-length signal.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a = signal(sin,ω=2kHz) |> until(2s)\nb = signal(sin,ω=1kHz) |> until(3s)\na_minus_b = mapsignal(-,a,b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The function mapsignal cannot itself be piped, due to ambiguity in the arguments, but shortcuts for this function have been provided for addition (mix) and multiplication (amplify), the two most common operations, and these two shortcuts have piped versions available.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a_plus_b = a |> mix(b)\na_times_b = a |> amplify(b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can also add or select out channels using addchannel and channel, which are defined in terms of calls to mapsignal. These use a variant of mapsignal where the keyword bychannel is set to false (see mapsignal's documentation for details).","category":"page"},{"location":"custom/#custom_signals-1","page":"Custom Signals","title":"Custom Signals","text":"","category":"section"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"Many signals can be readily created by passing a function to signal or by using mapsignal. However, in some cases it may be preferable to define a new signal type entirely. This allows for the most flexibility in terms of how the signal will behave within a chain of signal operators.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"To be propperly treated as a signal, an object must return an appropriate SignalOperators.IsSignal object when calling SignalOperators.SignalTrait.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"Any object returning SignalOperators.IsSignal should implement SignalOperators.nextblock, which is used to sequentially retrieve blocks from a signal. Analogous to Base.iterate, SignalOperators.nextblock will return nothing when there are no more blocks to produce. The blocks returned by SignalOperators.nextblock must implement the following two methods (which have fallbacks for AbstractArray objects).","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"nsamples Like a signal, each block has a fixed number of samples. Unlike signals, this cannot be an infinite or missing value. It should be a fast, type-stable function.\nSignalOperators.sample Individual samples of the block can be accessed by their index within the block (falling in the range of 1:nsamples(block)). This should be a fast, type-stable function. The method is guaranteed to only be called at most once for each index in the block. Normally, you should annotate it with @Base.propagate_inbounds just as you would an implementation of Baes.getindex.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"If you intend to simply returns blocks using arrays of data you can use SignalOperators.ArrayBlock, which will implement nsamples and sample for you.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"The custom signal will also need to implement methods for the following, signal-inspection methods.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"nsamples - to indicate how many samples are present in the signal;","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"this may be an infinite or missing value.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"samplerate - to indicate the sampling rate of the signal\nnchannels - to indicate how many channels per sample there are in this signal","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"Finally, there are several optional methods you can define for signals as well.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"signal - to enable one more other types to be interpreted as your","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"custom signal type.","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"duration - to allow missing values for nsamples and non-missing values for duration.\nSignalOperators.EvalTrait and tosamplerate - to enable custom handling of","category":"page"},{"location":"custom/#","page":"Custom Signals","title":"Custom Signals","text":"signal resmapling.","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Signal-Generation-1","page":"Reference","title":"Signal Generation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"signal\nsink\nsink!","category":"page"},{"location":"reference/#SignalOperators.signal","page":"Reference","title":"SignalOperators.signal","text":"signal(x,[samplerate])\n\nCoerce x to be a signal, optionally specifying its sample rate (usually in Hz). All signal operators first call signal(x) for each argument. This means you only need to call signal when you want to pass additional arguments to it.\n\nnote: Note\nIf you pipe signal and pass a sample rate, you must specify the units of the sample rate (e.g. x |> signal(20Hz)). A unitless number is always interpreted as a constant, infinite-length signal (see below).\n\nnote: Note\nIf you are implementing signal for a custom signal, you will need to support the second argument of signal by specifying fs::Union{Number,Missing}=missing, or equivalent, as your second argument.\n\nThe type of objects that can be coerced to signals are as follows.\n\n\n\n\n\nFilenames\n\nA string with a filename ending with an appropriate filetype can be read in as a signal. You will need to call import or using on the backend for reading the file.\n\nAvailable backends include the following pacakges\n\nWAV\nLibSndFile\n\n\n\n\n\nExisting signals\n\nAny existing signal just returns itself from signal. If a sample rate is specified it will be set if x has an unknown sample rate. If it has a known sample rate and doesn't match samplerate(x) an error will be thrown. If you want to change the sample rate of a signal use tosamplerate.\n\n\n\n\n\nNumbers\n\nNumbers can be treated as infinite length, constant signals of unknown sample rate.\n\n\n\n\n\nArrays\n\nArrays can be interpreted as signals. The first dimension is time, the second channels. By default their sample rate is a missing value.\n\nAxisArrays, if they have an axis labeled time and one or zero additional axes, can be treated as a signal. The time dimension must be represented using on object with the step function defined (e.g. any AbstractRange object).\n\nSampleBuf objects are also properly interpreted as signals.\n\n\n\n\n\nFunctions\n\nsignal(fn,[samplerate];[ω/frequency],[ϕ/phase])\n\nFunctions can define infinite length signals of known or unknown sample rate. The function fn can either return a number or, for multi-channel signals, a tuple of values.\n\nThe input to fn is either a phase value or a time value. If a frequency is specified (using either the ω or frequency keyword), the input to fn will be a phase value in radians, ranging from 0 to 2π. If no frequency is specified the value passed to fn is the time in seconds. Specifying phase (by the ϕ or phase keyword) will first add that value to the input before passing it to fn. When frequency is specified, the phase is assumed to be in units of radians (but you can also pass degrees by using ° or a unit of time (e.g. s for seconds)). When frequency is not specified the phase is assumed to be in units of seconds.\n\n\n\n\n\nIf fn == randn no frequency or phase can be specified. Instead there is a single keyword argument, rng, which allows you to specify the random number generator; rng defaults to Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink","page":"Reference","title":"SignalOperators.sink","text":"sink([signal],[to=AxisArray];duration,samplerate)\n\nCreates a given type of object (to) from a signal. By default it is an AxisArray with time as the rows and channels as the columns.\n\nKeyword arguments\n\nSample Rate\n\nThe sample rate does not need to be specified, it will use either the sample rate of signal or a default sample rate (which raises a warning). If specified, the given sample rate is passed to signal when coercing the input to a signal.\n\nDuration\n\nYou can limit the output of the given signal to the specified duration. If this duration exceedes the duration of the passed signal an error will be thrown.\n\nValues for to\n\nType\n\nIf to is a type (e.g. Array) the signal is written to a value of that type.\n\n\n\n\n\nFilename\n\nIf to is a string, it is assumed to describe the name of a file to which the signal will be written. You will need to call import or using on an appropriate backend for writing to the given file type.\n\nAvailable backends include the following pacakges\n\nWAV\nLibSndFile\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink!","page":"Reference","title":"SignalOperators.sink!","text":"sink!(array,x;[samplerate])\n\nWrite size(array,1) samples of signal x to array. If no sample rate has been specified for x you can specify it now, using samplerate (it will default to 44.1kHz).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Inspection-1","page":"Reference","title":"Signal Inspection","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"inflen\nduration\nnsamples\nnchannels\nsamplerate\nchannel_eltype","category":"page"},{"location":"reference/#SignalOperators.inflen","page":"Reference","title":"SignalOperators.inflen","text":"inflen\n\nRepresents an infinite length. Proper overloads are defined to handle arithmetic and ordering for the infinite value.\n\nMissing values\n\nFor the purposes of SignalOperators missing values are considered to be unknown, but of finite length. For example: inflen * missing == inflen.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SignalOperators.duration","page":"Reference","title":"SignalOperators.duration","text":"duration(x)\n\nReturn the duration of the signal in seconds, if known. May return missing or inflen. The value missing always denotes a finite but unknown length.\n\nnote: Note\nIf your are implementing a custom signal, you need not normally define duration as it will be computed from nsamples and samplerate. However, if one or both of these is missing and you want duartion to return a non-missing value, you can define custom method of duration.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nsamples","page":"Reference","title":"SignalOperators.nsamples","text":"nsamples(x)\n\nReturns the number of samples in the signal, if known. May return missing or inflen. The value missing always denotes a finite but unknown length.\n\nnote: Note\nThe return value of nsamples for a block (see custom signals must be a non-missing, finite value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nchannels","page":"Reference","title":"SignalOperators.nchannels","text":"nchannels(x)\n\nReturns the number of channels in the signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.samplerate","page":"Reference","title":"SignalOperators.samplerate","text":"samplerate(x)\n\nReturns the sample rate of the signal (in Hertz). May return missing if the sample rate is unknown.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.channel_eltype","page":"Reference","title":"SignalOperators.channel_eltype","text":"channel_eltype(x)\n\nReturns the element type of an individual channel of a signal (e.g. Float64).\n\nnote: Note\nchannel_eltype and eltype are, in most cases, the same, but not necesarilly so.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Reformatting-1","page":"Reference","title":"Signal Reformatting","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"tosamplerate\ntochannels\ntoeltype\nformat\nuniform","category":"page"},{"location":"reference/#SignalOperators.tosamplerate","page":"Reference","title":"SignalOperators.tosamplerate","text":"tosamplerate(x,fs;blocksize)\n\nChange the sample rate of x to the given sample rate fs. The underlying implementation depends on whether the input is a computed or data signal, as determined by EvalTrait.\n\nComputed signals (e.g. signal(sin)) are resampled exactly: the result is simply computed for more time points or fewer time points, so as to generate the appropriate number of samples.\n\nData-based signals (signal(rand(50,2))) are resampled using filtering (akin to DSP.resample). In this case you can use the keyword arugment blocksize to change the analysis window used. See filtersignal for more details. Setting blocksize for a computed signal will succeed, but different blocksize values have no effect on the underlying implementation.\n\nImplementation\n\nYou need only implement this function for custom signals for particular scenarios, described below.\n\nCustom Computed Signals\n\nIf you implement a new sigal type that is a computed signal, you must implement tosamplerate with the following type signature.\n\n\nfunction tosamplerate(x::MyCustomSignal,s::IsSignal{<:Any,<:Number},\n    c::ComputedSignal,samplerate;blocksize)\n\n    ## ...\nend\n\nThe result should be a new version of the computed signal with the given sample rate.\n\nHandling missing sample rates\n\nIf you implement a new signal type that can handle missing sample rate values, you will need to implement the following version of tosamplerate so that a known sample rate can be applied to a signal with a missing sample rate.\n\n\nfunction tosamplerate(x::MyCustomSignal,s::IsSignal{<:Any,Missing},\n    evaltrait,samplerate;blocksize)\n\n    ## ...\nend\n\nThe result should be a new version of the signal with the specified sample rate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.tochannels","page":"Reference","title":"SignalOperators.tochannels","text":"tochannels(x,ch)\n\nForce a signal to have ch number of channels, by mixing channels together or broadcasting a single channel over multiple channels.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.toeltype","page":"Reference","title":"SignalOperators.toeltype","text":"toeltype(x,T)\n\nConverts individual samples in signal x to type T.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.format","page":"Reference","title":"SignalOperators.format","text":"format(x,fs,ch)\n\nEfficiently convert both the samplerate (fs) and channels ch of signal x. This selects an optimal ordering for tosamplerate and tochannels to avoid redundant computations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.uniform","page":"Reference","title":"SignalOperators.uniform","text":"uniform(xs;channels=false)\n\nPromote the sample rate (and optionally the number of channels) to be the highest sample rate (and optionally highest channel count) of the iterable of signals xs.\n\nnote: Note\nuniform rarely needs to be called directly. It is called implicitly on all passed signals, within the body of operators such as mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Operators-1","page":"Reference","title":"Signal Operators","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"until\nafter\nappend\nprepend\npad\nmirror\ncycle\nlastsample\nSignalOperators.valuefunction\nfiltersignal\nlowpass\nhighpass\nbandpass\nbandstop\nnormpower\nmapsignal\nmix\namplify\naddchannel\nchannel\nrampon\nrampoff\nramp\nfadeto","category":"page"},{"location":"reference/#SignalOperators.until","page":"Reference","title":"SignalOperators.until","text":"until(x,time)\n\nCreate a signal of all samples of x up until and including time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.after","page":"Reference","title":"SignalOperators.after","text":"after(x,time)\n\nCreate a signal of all samples of x after time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.append","page":"Reference","title":"SignalOperators.append","text":"append(x,y,...)\n\nAppend a series of signals, one after the other.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.prepend","page":"Reference","title":"SignalOperators.prepend","text":"prepend(x,y,...)\n\nPrepend the series of signals: prepend(xs...) is equivalent to append(reverse(xs)...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.pad","page":"Reference","title":"SignalOperators.pad","text":"pad(x,padding)\n\nCreate a signal that appends an infinite number of values, padding, to x. The value padding can be:\n\na number\na tuple or vector\na type function: a one argument function of the channel_eltype of x\na value function: a one argument function of the signal x for which   SignalOperators.valuefunction(padding) == true.\nan indexing function: a three argument function following the same type signature as getindex for two dimensional arrays.\n\nIf the signal is already infinitely long (e.g. a previoulsy padded signal), pad has no effect.\n\nIf padding is a number it is used as the value for all samples and channels past the end of x.\n\nIf padding is a tuple or vector it is the value for all samples past the end of x.\n\nIf padding is a type function it is passed the channel_eltype of the signal and the resulting value is used as the value for all samples past the end of x. Examples include zero and one\n\nIf padding is a value function it is passed x just before padding during sink begins and it should return a tuple of channel_eltype(x) values. This value is repeated for the remaining samples. It is generally only useful when x is an AbstractArray.\n\nIf padding is an indexing function (it accepts 3 arguments) it will be used to retrieve samples from the signal x assuming it conforms to the AbstractArray interface, with the first index being samples and the second channels. If the sample index goes past the bounds of the array, it should be transformed to an index within the range of that array. Note that such padding functions only work on signals that are also AbstractArray objects. You can always generate an array from a given signal by first passing it through sink or sink!.\n\nSee also\n\ncycle mirror lastsample valuefunction\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mirror","page":"Reference","title":"SignalOperators.mirror","text":"mirror(x,i,j)\n\nAn indexing function which mirrors the indices when i > size(x,1). This means that past the end of the signal x, the signal first repeats with samples in reverse order, then repeats in the original order, so on and so forth. It can be passed as the second argument to  pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.cycle","page":"Reference","title":"SignalOperators.cycle","text":"cycle(x,i,j)\n\nAn indexing function which wraps index i using mod, thus repeating the signal when i > size(x,1). It can be passed as the second argument to pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.lastsample","page":"Reference","title":"SignalOperators.lastsample","text":"lastsample\n\nWhen passed as an argument to pad, allows padding using the last sample of a signal. You cannot use this function in other contexts, and it will normally throw an error. See pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.valuefunction","page":"Reference","title":"SignalOperators.valuefunction","text":"SignalOperators.valuefunction(fn)\n\nReturns true if fn should be treated as a value function. See pad. If you wish your own function to be a value function, you can do this as follows.\n\nSignalOperators.valuefunction(::typeof(myfun)) = true\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.filtersignal","page":"Reference","title":"SignalOperators.filtersignal","text":"filtersignal(x,h;[blocksize])\n\nApply the given filter h (from DSP) to signal x.\n\nBlocksize\n\nBlocksize determines the size of the buffer used when computing intermediate values of the filter. It defaults to 4096. It need not normally be adjusted.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.lowpass","page":"Reference","title":"SignalOperators.lowpass","text":"lowpass(x,low;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a lowpass filter to x at the given cutoff frequency (low). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.highpass","page":"Reference","title":"SignalOperators.highpass","text":"highpass(x,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a highpass filter to x at the given cutoff frequency (low). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandpass","page":"Reference","title":"SignalOperators.bandpass","text":"bandpass(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandpass filter to x at the given cutoff frequencies (low and high). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.bandstop","page":"Reference","title":"SignalOperators.bandstop","text":"bandstop(x,low,high;[order=5],[method=Butterworth(order)],[blocksize])\n\nApply a bandstop filter to x at the given cutoff frequencies (low and high). See filtersignal for details on blocksize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.normpower","page":"Reference","title":"SignalOperators.normpower","text":"normpower(x)\n\nReturn a signal with normalized power. That is, divide all samples by the root-mean-squared value of the entire signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mapsignal","page":"Reference","title":"SignalOperators.mapsignal","text":"mapsignal(fn,arguments...;padding,bychannel)\n\nApply fn across the samples of arguments, producing a signal of the output of fn. Shorter signals are padded to accommodate the longest finite-length signal. The function fn should treat each argument as a single number and return a single number. This operation is broadcast across all channels of the input. It is expected to be a type stable function.\n\nNormally the signals are first promoted to have the same samle rate and the same number of channels using uniform (with channels=true).\n\nCross-channel functions\n\nThe function fn is normally broadcast across channels, but if you wish to treat each channel separately you can set bychannel=false. In this case the inputs to fn will be indexable objects (tuples or arrays) of all channel values for a given sample, and fn should return a type-stable tuple value (for a multi-channel or single-channel result) or a number (for a single-channel result only). For example, the following would swap the left and right channels.\n\nx = rand(10,2)\nswapped = mapsignal(x,bychannel=false) do val\n    val[2],val[1]\nend\n\nWhen bychannel=false the channels of each signal are not promoted:\n\nPadding\n\nPadding determines how samples past the end of shorter signals are reported. The value of padding is passd to pad. Its default value is determined by the value of fn. The default value for the four basic arithmetic operators is their identity (one for * and zero for +). These defaults are set on the basis of fn using default_pad(fn). A fallback implementation of default_pad returns zero.\n\nTo define a new default for a specific function, just create a new method of default_pad(fn)\n\n\nmyfun(x) = 2x + 3\nSignalOperators.default_pad(::typeof(myfun)) = one\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mix","page":"Reference","title":"SignalOperators.mix","text":"mix(xs...)\n\nSum all signals together, using mapsignal\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.amplify","page":"Reference","title":"SignalOperators.amplify","text":"amplify(xs...)\n\nFind the product, on a per-sample basis, for all signals xs using mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.addchannel","page":"Reference","title":"SignalOperators.addchannel","text":"addchannel(xs...)\n\nConcatenate the channels of all signals into one signal, using mapsignal. This will result in a signal with sum(nchannels,xs) channels.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.channel","page":"Reference","title":"SignalOperators.channel","text":"channel(x,n)\n\nSelect channel n of signal x, as a single-channel signal, using mapsignal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampon","page":"Reference","title":"SignalOperators.rampon","text":"rampon(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampoff","page":"Reference","title":"SignalOperators.rampoff","text":"rampoff(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the offset of a signal, smoothly transitioning from full amplitude to 0 amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ramp","page":"Reference","title":"SignalOperators.ramp","text":"ramp(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset and offset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds at the start and from full to 0 amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.fadeto","page":"Reference","title":"SignalOperators.fadeto","text":"fadeto(x,y,[len=10ms],[fn=x->sinpi(0.5x)])\n\nAppend x to y, with a smooth transition lasting len seconds fading from x to y (so the total length is duration(x) + duration(y) - len).\n\nThis fade is accomplished with a rampoff of x and a rampon for y. fn should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Custom-Signals-1","page":"Reference","title":"Custom Signals","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"SignalOperators.SignalTrait\nSignalOperators.IsSignal\nSignalOperators.EvalTrait\nSignalOperators.nextblock\nSignalOperators.sample","category":"page"},{"location":"reference/#SignalOperators.SignalTrait","page":"Reference","title":"SignalOperators.SignalTrait","text":"SiganlOperators.SignalTrait(::Type{T}) where T\n\nReturns either nothing if the type T should not be considered a signal (the default) or IsSignal to indicate the signal format for this signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.IsSignal","page":"Reference","title":"SignalOperators.IsSignal","text":"SignalOperators.IsSignal{T,Fs,L}\n\nRepresents the format of a signal type with three type parameters:\n\nT - The channel_eltype of the signal.\nFs - The type of the samplerate. It should be either Float64 or   Missing.\nL - The type of the length of the signal. It should be either\n\nInfiniteLength, Missing or Int.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SignalOperators.EvalTrait","page":"Reference","title":"SignalOperators.EvalTrait","text":"SiganlOperators.EvalTrait(x)\n\nIndicates whether the signal is a DataSignal or ComputedSignal. Data signals represent samples concretely as a set of samples. Examples include arrays and numbers. Data signals generally return themselves, or some wrapper type when sink is called on them. Computed signals are any signal that invovles some intermediate computation, in which samples must be computued on the fly. Calls to sink on a computed signal results in some new, data signal. Most signals returned by a signal operator are computed signals.\n\nComputed signals have the extra responsibility of implementing tosamplerate\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nextblock","page":"Reference","title":"SignalOperators.nextblock","text":"SignalOperators.nextblock(x,maxlength,skip,[block])\n\nRetrieve the next block of samples for signal x. The final, fourth argument is optional. If it is left out, nextblock returns the first block of the signal. The resulting block must has no more than maxlength samples, but may have fewer samples than that; it should not have zero samples unless maxlength == 0. If skip == true, it is guaranted that sample will never be called on the returned block. The value of skip is true, for example, when skipping blocks during a call to after).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sample","page":"Reference","title":"SignalOperators.sample","text":"SignalOperators.sample(x,block,i)\n\nRetrieves the sample at index i of the given block of signal x. A sample is one or more channels of channel_eltype(x) values. The return value should be an indexable object (e.g. a number, tuple or array) of these channel values. This method should be implemented by blocks of custom signals.\n\n\n\n\n\n","category":"function"},{"location":"#SignalOperators.jl-1","page":"Home","title":"SignalOperators.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SignalOperators is a Julia package that aims to provide a clean interface for generating and manipulating signals: typically sounds, but any signal regularly sampled in time can be manipulated.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can install it in Julia by starting the Pkg prompt (hit ]), and using the add command.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(1.2) pkg> add SignalOperators","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As a preview of functionality, here are some example sound generation routines. You can find more detailed information in the manual and reference.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using SignalOperators\nusing SignalOperators.Units # allows the use of dB, Hz, s etc... as unitful values\n\n# a pure tone 20 dB below a power 1 signal, with on and off ramps (for\n# a smooth onset/offset)\nsound1 = signal(sin,ω=1kHz) |> until(5s) |> ramp |> normpower |> amplify(-20dB)\n\n# a sound defined by a file, matching the overall power to that of sound1\nsound2 = \"example.wav\" |> normpower |> amplify(-20dB)\n\n# a 1kHz sawtooth wave\nsound3 = signal(ϕ -> ϕ-π,ω=1kHz) |> ramp |> normpower |> amplify(-20dB)\n\n# a 5 Hz amplitude modulated noise\nsound4 = randn |>\n    amplify(signal(ϕ -> 0.5sin(ϕ) + 0.5,ω=5Hz)) |>\n    until(5s) |> normpower |> amplify(-20dB)\n\n# a 1kHz tone surrounded by a notch noise\nSNR = 5dB\nx = signal(sin,ω=1kHz) |> until(1s) |> ramp |> normpower |> amplify(-20dB + SNR)\ny = signal(randn) |> until(1s) |> bandstop(0.5kHz,2kHz) |> normpower |>\n  amplify(-20dB)\nscene = mix(x,y)\n\n# write all of the signals to a single file, at 44.1 kHz\nappend(sound1,sound2,sound3,sound4,scene) |> tosamplerate(44.1kHz) |> sink(\"examples.wav\")\n","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many thanks to @ssfrr for some great discussions during this PR, and related issues on the SampledSignals package. Those interactions definitely influenced my final design here.","category":"page"}]
}
