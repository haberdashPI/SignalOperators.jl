var documenterSearchIndex = {"docs":
[{"location":"custom_sink/#custom_sinks-1","page":"Custom Sinks","title":"Custom Sinks","text":"","category":"section"},{"location":"custom_sink/#","page":"Custom Sinks","title":"Custom Sinks","text":"You can create custom sinks, which can be passed to sink or sink! by defining two methods: SignalOperators.initsink and SignalOperators.sink_helper!. The first method is called when a call to sink is made (e.g. sink(MyCustomSink)). The second method is called inside sink! and provides the core operation to write blocks of frames to the sink. There is already a method of sink_helper! defined for AbstractArray objects, so you likely do not need to implement it if your custom sink is an AbtractArray.","category":"page"},{"location":"custom_sink/#","page":"Custom Sinks","title":"Custom Sinks","text":"You may also want to implement a constructor of the sink type that takes a single argument x of type SignalOperators.AbstractSignal. This should generally just call sink(x,CustomSink).","category":"page"},{"location":"custom_sink/#","page":"Custom Sinks","title":"Custom Sinks","text":"note: Note\nImplementing initsink is not strictly necessary. If you do not implement initsink you will only be able to write to the sink using sink!.","category":"page"},{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"SignalOperators is composed of a set of functions for generating, inspecting and operating over signals. Here, a \"signal\" is represented as a number of frames: each frame contains some number of channels (e.g. left and right speaker) with a sampled value (e.g. Float64) for each channel. The values are sampled regularly in time (e.g. every 100th of a second, or 100 Hz); this is referred to as the frame rate.","category":"page"},{"location":"manual/#Key-concepts-1","page":"Manual","title":"Key concepts","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several important concepts employed across the public interface. Let's step through one of the examples from the homepage (and README.md), which demonstrates most of these concepts.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = Signal(sin,ω=1kHz) |> Until(5s) |> Ramp |> Normpower |> Amplify(-20dB)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"This example creates a 1 kHz pure-tone (sine wave) that lasts 5 seconds. Its amplitude is 20 dB lower than a signal with unit 1 power.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are a few things going on here: piping, the use of units, lazy evaluation, infinite length signals and unspecified frame rates.","category":"page"},{"location":"manual/#Piping-1","page":"Manual","title":"Piping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Almost all of the operators in SignalOperators can be piped. This means that instead of passing the first argument you can pipe it using |>. For example, the two statements below have the same meaning.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = Signal(sin,ω=1kHz) |> Until(5s)\nsound1 = Until(Signal(sin,ω=1kHz),5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The use of piping makes it easier to read the sequence of operations that are performed on the signal.","category":"page"},{"location":"manual/#Units-1","page":"Manual","title":"Units","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In any place where a function needs a time or a frequency, it can be specified in appropriate units. There are many places where units can be passed. They all have a default assumed unit if a plain number without units is passed. The default units are seconds, Hertz, and radians as appropriate for the given argument.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 = Signal(sin,ω=1kHz)\nsound1 = Signal(sin,ω=1000)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Each unit is represented by a constant you can multiply by a number (in Julia, 10ms == 10*ms). To make use of the unit constants, you must call using SignalOperators.Units. This exports the following units: frames, kframes, Hz, kHz s, ms, rad, °, and dB. You can just include the ones you want using e.g. using SignalOperators.Units: Hz, or you can include more by adding the Unitful package to your project and adding the desired units from there. For example, using Unitful: MHz would include mega-Hertz frequencies (not normally useful for sound signals). Most of the default units have been re-exported from Unitful. However, the frames unit and its derivatives (e.g. kframes) are unique  to the SignalOperators package. They allow you to specify the time in terms of the number of frames: e.g. at a frame rate of 100 Hz, 2s == 200frames. Other powers of ten are represented for frames, (e.g. Mframes for mega-frames) but they are not exported (e.g. you would have to call SignalOperators.Units: Mframes before using 20Mframes).","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nYou can find the available powers-of-ten for units in Unitful.prefixdict","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Note that the output of functions to inspect a signal (e.g. duration, framerate) are bare values in the default unit (e.g. seconds or Hertz). No unit is explicitly provided by the return value.","category":"page"},{"location":"manual/#Decibels-1","page":"Manual","title":"Decibels","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can pass an amplification value as a unitless or a unitful value in dB; a unitless value is not assumed to be in decibels. Instead, it's assumed to be the actual ratio by which you wish to multiply the signal. For example, Amplify(x,2) will make x twice as loud while Amplify(x,2dB) will increase the amplitude by two decibells.","category":"page"},{"location":"manual/#Lazy-Evaluation-1","page":"Manual","title":"Lazy Evaluation","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"To ensure efficient signal generation, signal operators are lazy: no computations are performed until the actual signal data is requested. This lazy quality is reflected in the captilization of the operators: conceptually the operators define some new signal object which can be used to generate frames of data based on the input signal or signals.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"To request evaluation of a lazy signal you can use an array constructor: Array, AxisArray, DimensinoalArray or SampleBuf, or you can call the more general methods sink or sink!. The result of sink is itself a (non-lazy) signal. You can always specify the return type of sink, but by default it tries to maintain the same representation of the signal or signals used as input, favoring the earlier arguments over later arguments. For example sink(SampleBuf(rand(10,2),10) |> Mix(1)) isa SampleBuf.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The function sink can also write data to a file. To store the five second signal in the above example to \"example.wav\" we could write the following.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sound1 |> ToFramerate(44.1kHz) |> sink(\"example.wav\")","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"In this case sound1 had no defined frame rate, so we must specify one using ToFramerate.","category":"page"},{"location":"manual/#Non-lazy-operators-1","page":"Manual","title":"Non-lazy operators","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"If you prefer the result of an operator to be non-lazy, so you don't have to call sink first, you can make use the lower case versions of the operators. These operators do not allow for piping, as this would typically be quite inefficient. If you want to combine multiple operators, they should normally be evaluated lazily.","category":"page"},{"location":"manual/#Infinite-lengths-1","page":"Manual","title":"Infinite lengths","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Some of the ways you can define a signal lead to an infinite length signal. To allow for calls to sink, you have to specify the length, using Until. For example, when using Signal(sin), the signal is an infinite length sine wave. That's why, in the example above, we use Until to specify the length, as follows.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Signal(sin,ω=1kHz) |> Until(5s)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Infinite lengths are represented as the value inflen (e.g. when calling nframes). This has overloaded definitions of various operators to play nicely with ordering, arithmetic etc...","category":"page"},{"location":"manual/#Unspecified-frame-rates-1","page":"Manual","title":"Unspecified frame rates","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You may notice that the above signal has no defined frame rate. Such a signal is defined by a function, and can be sampled at whatever rate you desire. If you add a signal to the chain of operations that does have a defined frame rate, the unspecified frame rate will be resolved to that same rate (see signal promotion, below).","category":"page"},{"location":"manual/#Signal-promotion-1","page":"Manual","title":"Signal promotion","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A final concept, which is not as obvious from the examples, is the use of automatic signal promotion. When multiple signals are passed to the same operator, and they have a different number of channels or different frame rate, the signals are first converted to the highest fidelity format and then operated on. This allows for a relatively seamless chain of operations where you don't have to worry about the specific format of the signal, and you won't loose information about your signals unless you explicitly request a lower fidelity signal format (e.g. using ToChannels or ToFramerate).","category":"page"},{"location":"manual/#Signal-generation-1","page":"Manual","title":"Signal generation","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are four basic types that can be interpreted as signals: numbers, arrays, functions and files. Internally the function Signal is called on any object passed to a function that operates on a signal; you can call Signal yourself if you want to specify more information. For example, you may want to provide the exact frame rate the signal should be interpreted to have.","category":"page"},{"location":"manual/#Numbers-1","page":"Manual","title":"Numbers","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A number is treated as an infinite length signal, with unknown frame rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"1 |> Until(1s) |> ToFramerate(10Hz) |> sink == ones(10)","category":"page"},{"location":"manual/#Arrays-1","page":"Manual","title":"Arrays","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A standard array is treated as a finite signal with unknown frame rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"rand(10,2) |> ToFramerate(10Hz) |> sink |> duration == 1","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An AxisArray, DimesnionalArray or SampleBuf (from SampledSignals) is treated as a finite signal with a known frame rate (and is the default output of sink)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using AxisArrays\nx = AxisArray(rand(10,1),Axis{:time}(range(0,1,length=10)))\nframerate(x) == 10","category":"page"},{"location":"manual/#Functions-1","page":"Manual","title":"Functions","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A single argument function of time (in seconds) can be treated as an infinite signal. It can be also be a function of radians if you specify a frequency using ω (or frequency). See Signal's documentation for more details.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Signal(sin,ω=1kHz) |> duration |> isinf == true","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A small exception to this is randn. It can be used directly as a signal with unknown frame rate.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"randn |> duration == isinf","category":"page"},{"location":"manual/#Files-1","page":"Manual","title":"Files","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A file is interpreted as an audio file to be loaded into memory. You must include the WAV or LibSndFile package for this to work.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"using WAV\nx = Signal(\"example.wav\")","category":"page"},{"location":"manual/#Signal-inspection-1","page":"Manual","title":"Signal inspection","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can examine the properties of a signal using nframes, nchannels, framerate, and duration.","category":"page"},{"location":"manual/#Signal-operators-1","page":"Manual","title":"Signal operators","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are several categories of signal operators: extending, cutting, filtering, ramping, and mapping.","category":"page"},{"location":"manual/#Extending-1","page":"Manual","title":"Extending","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can extend a signal using Pad or Append. A padded signal becomes infinite by appending the signal by a repeated value, usually one or zero. You can append two or more signals (or Prepend) so they occur one after another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Pad(x,zero) |> duration |> isinf == true\nAppend(x,y,z) |> duration == duration(x) + duration(y) + duration(z)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nYou cannot append more than one new signal within a pipe. That is, the following will throw an error.# Don't do this!\nx |> Append(y,z)This is because Append(y,z) does not return a function to be piped (as Append(y) does). It returns a signal with y followed by z. You can instead call this as follows.# This will do what you want!\nx |> Append(y) |> Append(z)","category":"page"},{"location":"manual/#Cutting-1","page":"Manual","title":"Cutting","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can cut signals apart, removing either the end of the signal (Until) or the beginning (After). The operations are exact compliments of one another.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Append(Until(x,2s),After(x,2s)) |> nframes == nframes(x)","category":"page"},{"location":"manual/#Filtering-1","page":"Manual","title":"Filtering","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can filter signals, removing undesired frequencies using Filt.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Signal(randn) |> Filt(Lowpass,20Hz)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"warning: Warning\nIf you write using DSP you will have to also write dB = SignalOperators.Units.dB if you want to make use of the proper meaning of dB for SignalOperators: DSP also defines dB.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"An unusual filter is Normpower: it computes the root mean squared power of the signal and then normalizes each frame by that value.","category":"page"},{"location":"manual/#Ramping-1","page":"Manual","title":"Ramping","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A Ramp allows for smooth transitions between 0 amplitude and the full amplitude of the signal. It is useful to avoid clicks in the onset or offset of a sound. For example, pure-tones are typically ramped when presented.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Signal(sin,ω=2kHz) |> Until(5s) |> Ramp","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"You can ramp only the start of a signal (RampOn), or the end of it (RampOff) and you can use ramps to create a smooth transition between two signals (FadeTo).","category":"page"},{"location":"manual/#General-operators-1","page":"Manual","title":"General operators","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The most general operator is OperateOn. It works a lot like map but automatically promotes the signals, as with all operators, and it pads the end of the signal appropriately, so different length signals can be combined. The output is always the length of the longest finite-length signal.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a = Signal(sin,ω=2kHz) |> Until(2s)\nb = Signal(sin,ω=1kHz) |> Until(3s)\na_minus_b = OperateOn(-,a,b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The function OperateOn cannot itself be piped, due to ambiguity in the arguments, but you can use the shorter Operate for these purposes.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a_minus_b = a |> Operate(-,b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"A number of shortcuts for OperateOn exist, and these can be piped normally. There are shortcuts for addition (Mix) and multiplication (Amplify).","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"a_plus_b = a |> Mix(b)\na_times_b = a |> Amplify(b)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"There are shortcuts to add or isolate channels, AddChannel and SelectChannel. These set the keyword argument bychannel of OperateOn to false (see OperateOn's documentation for details).","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Signal-Generation-1","page":"Reference","title":"Signal Generation","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Signal\nsink\nsink!","category":"page"},{"location":"reference/#SignalOperators.Signal","page":"Reference","title":"SignalOperators.Signal","text":"Signal(x,[framerate])\n\nCoerce x to be a signal, optionally specifying its frame rate (usually in Hz). All signal operators first call Signal(x) for each argument. This means you only need to call Signal when you want to pass additional arguments to it.\n\nnote: Note\nIf you pipe Signal and pass a frame rate, you must specify the units of the frame rate (e.g. x |> Signal(20Hz)). A unitless number is always interpreted as a constant, infinite-length signal (see below).\n\nnote: Note\nIf you are implementing Signal for a custom signal, you will need to support the second argument of Signal by specifying fs::Union{Number,Missing}=missing, or equivalent.\n\nThe type of objects that can be coerced to signals are as follows.\n\n\n\n\n\nFilenames\n\nA string with a filename ending with an appropriate filetype can be read in as a signal. You will need to call import or using on the backend for reading the file.\n\nAvailable backends include the following pacakges\n\nWAV\nLibSndFile\n\n\n\n\n\nExisting signals\n\nAny existing signal just returns itself from Signal. If a frame rate is specified it will be set if x has an unknown frame rate. If it has a known frame rate and doesn't match framerate(x) an error will be thrown. If you want to change the frame rate of a signal use ToFramerate.\n\n\n\n\n\nNumbers\n\nNumbers can be treated as infinite length, constant signals of unknown frame rate.\n\nExample\n\nrand(10,2) |> Amplify(20dB) |> nframes == 10\n\n\nnote: Note\nThe length of numbers are treated specially when passed to OperateOn: if there are other types of signal passed as input, the number signals are considered to be as long as the longest signal.nframes(Mix(1,2)) == inflen\nnframes(Mix(1,rand(10,2))) == 10\n\n\n\n\n\nArrays\n\nAny array can be interpreted as a signal. By default the first dimension is time, the second channels and their frame rate is a missing value. If you pass a non-missin gframerate, and the array currently has a missing frame rate a Tuple value will be returned (see \"Array & Number\" below).\n\nIf you specify a non-missing frame rate to an array type with a missing frame rate the return value will be a Tuple (see Array & Number section below). Some array types change this default behavior, as follows.\n\nwarning: Warning\nArrays of more than two dimensions are not currently supported.\n\nAxisArrays, if they have an   axis labeled time and one or zero additional axes, can be treated as a   signal. The time dimension must be represented using on object with the step   function defined (e.g. any AbstractRange object).\nSampleBuf objects are   also properly interpreted as signals, as per the conventions employed for its   package.\nDimensionalArrays can be   treated as signals if there is a Time dimension, which must be represented   using an object with the step function defined (e.g. AbstractRange) and   zero or one additional dimensions (treated as channels)\n\n\n\n\n\nArray & Number\n\nA tuple of an array and a number can be interepted as a signal. The first dimension is time, the second channels, and the number determines the frame rate (in Hertz).\n\n\n\n\n\nFunctions\n\nSignal(fn,[framerate];[ω/frequency],[ϕ/phase])\n\nFunctions can define infinite length signals of known or unknown frame rate. The function fn can either return a number or, for multi-channel signals, a tuple of values.\n\nThe input to fn is either a phase value or a time value. If a frequency is specified (using either the ω or frequency keyword), the input to fn will be a phase value in radians, ranging from 0 to 2π. If no frequency is specified the value passed to fn is the time in seconds. Specifying phase (by the ϕ or phase keyword) will first add that value to the input before passing it to fn. When frequency is specified, the phase is assumed to be in units of radians (but you can also pass degrees by using ° or a unit of time (e.g. s for seconds)). When frequency is not specified the phase is assumed to be in units of seconds.\n\n\n\n\n\nIf fn == randn no frequency or phase can be specified. Instead there is a single keyword argument, rng, which allows you to specify the random number generator; rng defaults to Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink","page":"Reference","title":"SignalOperators.sink","text":"sink(signal,[to])\n\nCreates a given type of object (to) from a signal. By default the type of the resulting sink is determined by the type of the underlying data of the signal: e.g. if x is a SampleBuf object then sink(Mix(x,2)) is also a SampleBuf object. If there is no underlying data (Signal(sin) |> sink) then a Tuple of an array and the framerate is returned.\n\nwarning: Warning\nThough sink often makes a copy of an input array, it is not guaranteed to do so. For instance sink(Until(rand(10),5frames)) will simply take a view of the first 5 frames of the input.\n\nValues for to\n\nType\n\nIf to is an array type (e.g. Array, DimensionalArray) the signal is written to a value of that type.\n\nIf to is a Tuple the result is an Array of samples and a number indicating the sample rate in Hertz.\n\n\n\n\n\nFilename\n\nIf to is a string, it is assumed to describe the name of a file to which the signal will be written. You will need to call import or using on an appropriate backend for writing to the given file type.\n\nAvailable backends include the following pacakges\n\nWAV\nLibSndFile\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink!","page":"Reference","title":"SignalOperators.sink!","text":"sink!(array,x)\n\nWrite size(array,1) frames of signal x to array.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Inspection-1","page":"Reference","title":"Signal Inspection","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"inflen\nduration\nnframes\nnchannels\nframerate\nsampletype","category":"page"},{"location":"reference/#SignalOperators.inflen","page":"Reference","title":"SignalOperators.inflen","text":"inflen\n\nRepresents an infinite length. Proper overloads are defined to handle arithmetic and ordering for the infinite value.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#SignalBase.duration","page":"Reference","title":"SignalBase.duration","text":"duration(x)\n\nReturn the duration of the signal in seconds, if known. May return missing (e.g. for a stream).\n\nnote: Note\nA fallback implementation of duration uses nframes(x) / framerate(x). However, if one or both of these is missing and you want duartion to return a non-missing value, you can define a custom method of duration.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalBase.nframes","page":"Reference","title":"SignalBase.nframes","text":"nframes(x)\n\nReturns the number of frames in the signal, if known. May return missing  (e.g. for a file stream).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalBase.nchannels","page":"Reference","title":"SignalBase.nchannels","text":"nchannels(x)\n\nReturns the number of channels in the signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalBase.framerate","page":"Reference","title":"SignalBase.framerate","text":"framerate(x)\n\nReturns the frame rate of the signal (in Hertz). May return missing if the frame rate is unknown.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalBase.sampletype","page":"Reference","title":"SignalBase.sampletype","text":"sampletype(x)\n\nReturns the element type of an individual channel of a signal (e.g. Float64).\n\nnote: Note\nThe result of sampletype and eltype (when defined) are often the same. They are distinct so that these two can diverge when appropriate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Signal-Operators-1","page":"Reference","title":"Signal Operators","text":"","category":"section"},{"location":"reference/#Basic-Operators-1","page":"Reference","title":"Basic Operators","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Until\nuntil\nAfter\nafter\nWindow\nwindow\nAppend\nappend\nPrepend\nprepend\nPad\nExtend\nmirror\ncycle\nlastframe\nSignalOperators.valuefunction","category":"page"},{"location":"reference/#SignalOperators.Until","page":"Reference","title":"SignalOperators.Until","text":"Until(x,time)\n\nCreate a signal of all frames of x up until and including time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.until","page":"Reference","title":"SignalOperators.until","text":"until(x,time)\n\nEquivalent to sink(Until(x,time))\n\nSee also\n\nUntil\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.After","page":"Reference","title":"SignalOperators.After","text":"After(x,time)\n\nCreate a signal of all frames of x after time.\n\nnote: Note\nIf you use frames as the unit here, keep in mind that because this returns all frames after the given index, the result is effectively zero indexed: i.e. all(sink(After(1:10,1frames)) .== 2:10)\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.after","page":"Reference","title":"SignalOperators.after","text":"after(x,time)\n\nEquivalent to sink(After(x,time))\n\nSee also\n\nAfter\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Window","page":"Reference","title":"SignalOperators.Window","text":"Window(x;from,to)\nWindow(x;at,width)\n\nExtract a window of time from a signal by specifying either the start and stop point of the window (from and to) or the center and width (at and wdith) of the window.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.window","page":"Reference","title":"SignalOperators.window","text":"window(x;from,to)\nwindow(x;at,width)\n\nEquivalent to sink(Window(...)).\n\nSee also\n\nWindow\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Append","page":"Reference","title":"SignalOperators.Append","text":"Append(x,y,...)\n\nAppend a series of signals, one after the other.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.append","page":"Reference","title":"SignalOperators.append","text":"append(x,y,...)\n\nEquivalent to sink(Append(x,y,...))\n\nSee also\n\nAppend\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Prepend","page":"Reference","title":"SignalOperators.Prepend","text":"Prepend(x,y,...)\n\nPrepend the series of signals: Prepend(xs...) is equivalent to Append(reverse(xs)...).\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.prepend","page":"Reference","title":"SignalOperators.prepend","text":"prepend(x,y,...)\n\nEquivalent to sink(Prepend(x,y,...))\n\nSee also\n\nPrepend\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Pad","page":"Reference","title":"SignalOperators.Pad","text":"Pad(x,padding)\n\nCreate a signal that appends an infinite number of values, padding, to x. The value padding can be:\n\na number\na tuple or vector\na type function: a one argument function of the sampletype of x\na value function: a one argument function of the signal x for which   SignalOperators.valuefunction(padding) == true.\nan indexing function: a three argument function following the same type signature as getindex for two dimensional arrays.\n\nIf the signal is already infinitely long (e.g. a previoulsy padded signal), Pad has no effect.\n\nIf padding is a number it is used as the value for all samples past the end of x.\n\nIf padding is a tuple or vector it is the value for all frames past the end of x.\n\nIf padding is a type function it is passed the sampletype of the signal and the resulting value is used as the value for all frames past the end of x. Examples include zero and one\n\nIf padding is a value function it is passed the signal x just before padding occurs during a call to sink; it should return a tuple of sampletype(x) values. The return value is repeated for all remaining frames of the signal. For example, lastframe is a value function.\n\nIf padding is an indexing function (it accepts 3 arguments) it will be used to retrieve frames from the signal x assuming it conforms to the AbstractArray interface, with the first index being frames and the second channels. If the frame index goes past the bounds of the array, it should be transformed to an index within the range of that array. Note that such padding functions only work on signals that are also AbstractArray objects. You can always generate an array from a given signal by first passing it through sink or sink!.\n\ninfo: Info\nA indexing function will also work on a signal represented as a tuple of an array and number; it simply passed the array (leaving off the number).\n\nSee also\n\nExtend cycle mirror lastframe valuefunction\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Extend","page":"Reference","title":"SignalOperators.Extend","text":"Extend(x,padding)\n\nBehaves like Pad, except when passed directly to OperateOn; in that case, the signal x will only be padded up to the length of the longest signal input to OperateOn\n\nSee Also\n\nOperateOn Pad\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mirror","page":"Reference","title":"SignalOperators.mirror","text":"mirror(x,i,j)\n\nAn indexing function which mirrors the indices when i > size(x,1). This means that past the end of the signal x, the signal first repeats with frames in reverse order, then repeats in the original order, so on and so forth. It can be passed as the second argument to  Pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.cycle","page":"Reference","title":"SignalOperators.cycle","text":"cycle(x,i,j)\n\nAn indexing function which wraps index i using mod, thus repeating the signal when i > size(x,1). It can be passed as the second argument to Pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.lastframe","page":"Reference","title":"SignalOperators.lastframe","text":"lastframe\n\nWhen passed as an argument to Pad, allows padding using the last frame of a signal. You cannot use this function in other contexts, and it will normally throw an error. See Pad.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.valuefunction","page":"Reference","title":"SignalOperators.valuefunction","text":"SignalOperators.valuefunction(fn)\n\nReturns true if fn should be treated as a value function. See Pad. If you wish your own function to be a value function, you can do this as follows.\n\nSignalOperators.valuefunction(::typeof(myfun)) = true\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mapping-Operators-1","page":"Reference","title":"Mapping Operators","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Filt\nNormpower\nnormpower\nOperateOn\nOperate\noperate\nMix\nmix\nAmplify\namplify\nAddChannel\naddchannel\nSelectChannel\nselectchannel","category":"page"},{"location":"reference/#SignalOperators.Filt","page":"Reference","title":"SignalOperators.Filt","text":"Filt(x,::Type{<:FilterType},bounds...;method=Butterworth(order),order=5,\n     blocksize=4096)\n\nApply the given filter type (e.g. Lowpass) using the given method to design the filter coefficients. The type is specified as per the types from DSP\n\nFilt(x,h;[blocksize=4096])\n\nApply the given digital filter h (from DSP) to signal x.\n\nBlocksize\n\nBlocksize determines the size of the buffer used when computing intermediate values of the filter. It need not normally be adjusted, though changing it can alter how efficient filter application is.\n\nnote: Note\nThe non-lazy version of Filt is filt from the DSP package. Proper methods have been defined such that it should be possible to call filt on a signal and get a signal back.The argument order for filt follows a different convention, with x coming after the filter specification. In contrast, Filt uses the convention of keeping x as the first argument to make piping possible.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Normpower","page":"Reference","title":"SignalOperators.Normpower","text":"Normpower(x)\n\nReturn a signal with normalized power. That is, divide all frames by the root-mean-squared value of the entire signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.normpower","page":"Reference","title":"SignalOperators.normpower","text":"normpower(x)\n\nEquivalent to sink(Normpower(x))\n\nSee also\n\nNormpower\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.OperateOn","page":"Reference","title":"SignalOperators.OperateOn","text":"OperateOn(fn,arguments...;padding=default_pad(fn),bychannel=false)\n\nApply fn across the samples of the passed signals. The output length is the maximum length of the arguments. Shorter signals are extended using Extend(x,padding).\n\nnote: Note\nThere is no piped version of OperateOn, use Operate to pipe. The shorter name is used to pipe because it is expected to be the more common use case.\n\nChannel-by-channel functions (default)\n\nWhen bychannel == false the function fn should treat each of its arguments as a single number and return a single number. This operation is broadcast across all channels of the input. It is expected to be a type stable function.\n\nThe signals are first promoted to have the same sample rate and the same number of channels using Uniform.\n\nCross-channel functions\n\nWhen bychannel=false, rather than being applied to each channel seperately the function fn is applied to each frame, containing all channels. For example, for a two channel signal, the following would swap these two channels.\n\nx = rand(10,2)\nswapped = OperateOn(x,bychannel=false) do val\n    val[2],val[1]\nend\n\nThe signals are first promoted to have the same sample rate, but the number of channels of each input signal remains unchanged.\n\nPadding\n\nPadding determines how frames past the end of shorter signals are reported. If you wish to change the padding for all signals you can set the value of the keyword argument padding. If you wish to specify distinct padding values for some of the inputs, you can first call Extend on those arguments.\n\nThe default value for padding is determined by the fn passed. A fallback implementation of default_pad returns zero. The default value for the four basic arithmetic operators is their identity (one for * and zero for +).\n\nTo define a new default for a specific function, just create a new method of default_pad(fn)\n\nmyfun(x,y) = x + 2y\nSignalOperators.default_pad(::typeof(myfun)) = one\n\nsink(OperateOn(myfun,Until(5,2frames),Until(2,4frames))) == [9,9,5,5]\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Operate","page":"Reference","title":"SignalOperators.Operate","text":"Operate(fn,rest...;padding,bychannel)\n\nEquivalent to\n\njulia (x) -> OperateOn(fn,x,rest...;padding=padding,bychannel=bychannel)`\n\nSee also\n\nOperateOn\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.operate","page":"Reference","title":"SignalOperators.operate","text":"operate(fn,args...;padding,bychannel)\n\nEquivalent to sink(OperateOn(fn,args...;padding,bychannel))\n\nSee also\n\nOperateOn\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Mix","page":"Reference","title":"SignalOperators.Mix","text":"Mix(xs...)\n\nSum all signals together, using OperateOn. Unlike OperateOn, Mix includes a piped version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.mix","page":"Reference","title":"SignalOperators.mix","text":"mix(xs...)\n\nEquivalent to sink(Mix(xs...))\n\nSee also\n\nMix\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Amplify","page":"Reference","title":"SignalOperators.Amplify","text":"Amplify(xs...)\n\nFind the product, on a per-frame basis, for all signals xs using OperateOn. Unlike OperateOn, Amplify includes a piped version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.amplify","page":"Reference","title":"SignalOperators.amplify","text":"amplify(xs...)\n\nEquivalent to sink(Amplify(xs...))\n\nSee also\n\nAmplify\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.AddChannel","page":"Reference","title":"SignalOperators.AddChannel","text":"AddChannel(xs...)\n\nConcatenate the channels of all signals into one signal, using OperateOn. This will result in a signal with sum(nchannels,xs) channels. Unlike OperateOn, AddChannels includes a piped version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.addchannel","page":"Reference","title":"SignalOperators.addchannel","text":"addchannel(xs...)\n\nEquivalent to sink(AddChannel(xs...)).\n\nSee also\n\nAddChannel\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.SelectChannel","page":"Reference","title":"SignalOperators.SelectChannel","text":"SelectChannel(x,n)\n\nSelect channel n of signal x, as a single-channel signal, using OperateOn. Unlike OperateOn, SelectChannel includes a piped version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.selectchannel","page":"Reference","title":"SignalOperators.selectchannel","text":"selectchannel(xs...)\n\nEquivalent to sink(SelectChannel(xs...))\n\nSee also\n\nSelectChannel\n\n\n\n\n\n","category":"function"},{"location":"reference/#Ramping-Operators-1","page":"Reference","title":"Ramping Operators","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"RampOn\nrampon\nRampOff\nrampoff\nRamp\nramp\nFadeTo\nfadeto","category":"page"},{"location":"reference/#SignalOperators.RampOn","page":"Reference","title":"SignalOperators.RampOn","text":"RampOn(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampon","page":"Reference","title":"SignalOperators.rampon","text":"rampon(x,[len],[fn])\n\nEquivalent to sink(RampOn(x,[len],[fn]))\n\nSee also\n\nRampOn\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.RampOff","page":"Reference","title":"SignalOperators.RampOff","text":"RampOff(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the offset of a signal, smoothly transitioning from full amplitude to 0 amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.rampoff","page":"Reference","title":"SignalOperators.rampoff","text":"rampoff(x,[len],[fn])\n\nEquivalent to sink(RampOff(x,[len],[fn]))\n\nSee also\n\nRampOff\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Ramp","page":"Reference","title":"SignalOperators.Ramp","text":"Ramp(x,[len=10ms],[fn=x -> sinpi(0.5x)])\n\nRamp the onset and offset of a signal, smoothly transitioning from 0 to full amplitude over the course of len seconds at the start and from full to 0 amplitude over the course of len seconds.\n\nThe function determines the shape of the ramp and should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ramp","page":"Reference","title":"SignalOperators.ramp","text":"ramp(x,[len],[fn])\n\nEquivalent to sink(Ramp(x,[len],[fn]))\n\nSee also\n\nRamp\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.FadeTo","page":"Reference","title":"SignalOperators.FadeTo","text":"FadeTo(x,y,[len=10ms],[fn=x->sinpi(0.5x)])\n\nAppend x to y, with a smooth transition lasting len seconds fading from x to y (so the total length is duration(x) + duration(y) - len).\n\nThis fade is accomplished with a RampOff of x and a RampOn for y. fn should be non-decreasing with a range of [0,1] over the domain [0,1]. It should map over the entire range: that is fn(0) == 0 and fn(1) == 1.\n\nBoth len and fn are optional arguments: either one or both can be specified, though len must occur before fn if present.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.fadeto","page":"Reference","title":"SignalOperators.fadeto","text":"fadeto(x,y,[len],[fn])\n\nEquivalent to sink(FadeTo(x,[len],[fn]))\n\nSee also\n\nFadeTo\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reformatting-Operators-1","page":"Reference","title":"Reformatting Operators","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"ToFramerate\ntoframerate\nToChannels\ntochannels\nToEltype\ntoeltype\nFormat\nformat\nUniform","category":"page"},{"location":"reference/#SignalOperators.ToFramerate","page":"Reference","title":"SignalOperators.ToFramerate","text":"ToFramerate(x,fs;blocksize)\n\nChange the frame rate of x to the given frame rate fs. The underlying implementation depends on whether the input is a computed or data signal, as determined by EvalTrait.\n\nComputed signals (e.g. Signal(sin)) are resampled exactly: the result is simply computed for more time points or fewer time points, so as to generate the appropriate number of frames.\n\nData-based signals (Signal(rand(50,2))) are resampled using filtering (akin to DSP.resample). In this case you can use the keyword arugment blocksize to change the analysis window used. See Filt for more details. Setting blocksize for a computed signal will succeed, but different blocksize values have no effect on the underlying implementation.\n\nImplementation\n\nYou need only implement this function for custom signals for particular scenarios, described below.\n\nCustom Computed Signals\n\nIf you implement a new sigal type that is a computed signal, you must implement ToFramerate with the following type signature.\n\n\nfunction ToFramerate(x::MyCustomSignal,s::IsSignal{<:Any,<:Number},\n    c::ComputedSignal,framerate;blocksize)\n\n    ## ...\nend\n\nThe result should be a new version of the computed signal with the given frame rate.\n\nHandling missing frame rates\n\nIf you implement a new signal type that can handle missing frame rate values, you will need to implement the following version of ToFramerate so that a known frame rate can be applied to a signal with a missing frame rate.\n\n\nfunction ToFramerate(x::MyCustomSignal,s::IsSignal{<:Any,Missing},\n    evaltrait,framerate;blocksize)\n\n    ## ...\nend\n\nThe result should be a new version of the signal with the specified frame rate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.toframerate","page":"Reference","title":"SignalOperators.toframerate","text":"toframerate(x,fs;blocksize)\n\nEquivalent to sink(ToFramerate(x,fs;blocksize=blocksize))\n\nSee also\n\nToFramerate\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ToChannels","page":"Reference","title":"SignalOperators.ToChannels","text":"ToChannels(x,ch)\n\nForce a signal to have ch number of channels, by mixing channels together or broadcasting a single channel over multiple channels.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.tochannels","page":"Reference","title":"SignalOperators.tochannels","text":"tochannels(x,ch)\n\nEquivalent to sink(ToChannels(x,ch))\n\nSee also\n\nToFramerate\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ToEltype","page":"Reference","title":"SignalOperators.ToEltype","text":"ToEltype(x,T)\n\nConverts individual samples in signal x to type T.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.toeltype","page":"Reference","title":"SignalOperators.toeltype","text":"toeltype(x,T)\n\nEquivalent to sink(ToEltype(x,T))\n\nSee also\n\nToEltype\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Format","page":"Reference","title":"SignalOperators.Format","text":"Format(x,fs,ch)\n\nEfficiently convert both the framerate (fs) and channels ch of signal x. This selects an optimal ordering for ToFramerate and ToChannels to avoid redundant computations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.format","page":"Reference","title":"SignalOperators.format","text":"format(x,fs,ch)\n\nEquivalent to sink(Format(x,fs,ch))\n\nSee also\n\nFormat\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.Uniform","page":"Reference","title":"SignalOperators.Uniform","text":"Uniform(xs;channels=false)\n\nPromote the frame rate (and optionally the number of channels) to be the highest frame rate (and optionally highest channel count) of the iterable of signals xs.\n\nnote: Note\nUniform rarely needs to be called directly. It is called implicitly on all passed signals, within the body of operators such as OperateOn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Custom-Signals-1","page":"Reference","title":"Custom Signals","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"SignalOperators.SignalTrait\nSignalOperators.IsSignal\nSignalOperators.EvalTrait\nSignalOperators.nextblock\nSignalOperators.frame\nSignalOperators.timeslice\nSignalOperators.ArrayBlock","category":"page"},{"location":"reference/#SignalOperators.SignalTrait","page":"Reference","title":"SignalOperators.SignalTrait","text":"SiganlOperators.SignalTrait(::Type{T}) where T\n\nReturns either nothing if the type T should not be considered a signal (the default) or IsSignal to indicate the signal format for this signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.IsSignal","page":"Reference","title":"SignalOperators.IsSignal","text":"SignalOperators.IsSignal{T,Fs,L}\n\nRepresents the format of a signal type with three type parameters:\n\nT - The sampletype of the signal.\nFs - The type of the framerate. It should be either Float64 or   Missing.\nL - The type of the length of the signal. It should be either   Infinity, Missing or Int.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SignalOperators.EvalTrait","page":"Reference","title":"SignalOperators.EvalTrait","text":"SiganlOperators.EvalTrait(x)\n\nIndicates whether the signal is a DataSignal or ComputedSignal. Data signals represent frames concretely as a set of frames. Examples include arrays and numbers. Data signals generally return themselves, or some wrapper type when sink is called on them. Computed signals are any signal that invovles some intermediate computation, in which frames must be computued on the fly. Calls to sink on a computed signal results in some new, data signal. Most signals returned by a signal operator are computed signals.\n\nComputed signals have the extra responsibility of implementing ToFramerate\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.nextblock","page":"Reference","title":"SignalOperators.nextblock","text":"SignalOperators.nextblock(x,maxlength,skip,[last_block])\n\nRetrieve the next block of frames for signal x, or nothing, if no more blocks exist. Analogous to Base.iterate. The returned block must satisfy the interface for signal blocks as described in custom signals.\n\nArugments\n\nx: the signal to retriev blocks from\nmaxlength: The resulting block must have no more than maxlength frames,   but may have fewer frames than that; it should not have zero frames unless   maxlength == 0.\nskip: If skip == true, it is guaranted that frame   will never be called on the returned block. The value of skip is true   when skipping blocks during a call to After).\nlast_block The fourth argument is optional. If included, the block that   occurs after this block is returned. If it is left out, nextblock returns the   very first block of the signal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.frame","page":"Reference","title":"SignalOperators.frame","text":"SignalOperators.frame(x,block,i)\n\nRetrieves the frame at index i of the given block of signal x. A frame is one or more channels of sampletype(x) values. The return value should be an indexable object (e.g. a number, tuple or array) of these channel values. This method should be implemented by blocks of custom signals.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.timeslice","page":"Reference","title":"SignalOperators.timeslice","text":"SignalOperators.timeslice(x::AbstractArray,indices)\n\nExtract the slice of x with the given time indices.\n\nCustom signals can implement this method if the signal is an AbstractArray allowing the use of a fallback implementation of SignalOperators.nextblock.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.ArrayBlock","page":"Reference","title":"SignalOperators.ArrayBlock","text":"ArrayBlock{A,S}(data::A,state::S)\n\nA straightforward implementation of blocks as an array and a custom state. The array allows a generic implementation of nframes and SignalOperators.frame. The fields of this struct are data and state.\n\nCustom signals can return an ArrayBlock from SignalOperators.nextblock to allow for fallback implementations of nframes and SignalOperators.frame.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Custom-Sinks-1","page":"Reference","title":"Custom Sinks","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"SignalOperators.initsink\nSignalOperators.sink_helper!","category":"page"},{"location":"reference/#SignalOperators.initsink","page":"Reference","title":"SignalOperators.initsink","text":"SignalOperators.initsink(x,::Type{T})\n\nInitialize an object of type T so that it can store all frames of signal x.\n\nIf you wish an object to serve as a custom sink you can implement this method. You can use nchannels and sampletype of x to determine how to initialize the object for the first method, or you can just use initsink(x,Array) and wrap the return value with your custom type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SignalOperators.sink_helper!","page":"Reference","title":"SignalOperators.sink_helper!","text":"SignalOperators.sink_helper!(result,written,x,block)\n\nWrite the given block of frames from signal x to result given that a total of written frames have already been written to the result.\n\nThis method should be fast: i.e. a for loop using @simd and @inbounds. It should call nframes and SignalOperators.frame on the block to write the frames. Do not call frame more than once for each index of the block.\n\n\n\n\n\n","category":"function"},{"location":"custom_signal/#custom_signals-1","page":"Custom Signals","title":"Custom Signals","text":"","category":"section"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"To treat new custom objects as signals, you must support the signal interface. Such an object must return an appropriate SignalOperators.IsSignal object when calling SignalOperators.SignalTrait.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"IsSignal is an emptry struct that has three type parameters, indicating the sampletype the type of framerate and the type used to represent the length returned by nframes. For example, for an array SignalTrait is implemented as follows.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"SignalTrait(x::Type{<:Array{T}}) where T = IsSignal{T,Missing,Int}","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"All signals should implement the appropriate methods from SignalBase. What additional methods you should implement depends on what kind of signal you have.","category":"page"},{"location":"custom_signal/#AbstractArray-objects-1","page":"Custom Signals","title":"AbstractArray objects","text":"","category":"section"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"If your signal is an array of some kind you should implement SignalOperators.timeslice, which should return a requested range of frames from the signal.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"You should also consider defining your array type to be a custom sink.","category":"page"},{"location":"custom_signal/#Other-objects-1","page":"Custom Signals","title":"Other objects","text":"","category":"section"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"Any other type of signal should implement SignalOperators.nextblock, which is used to sequentially retrieve blocks from a signal.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"Analogous to Base.iterate, SignalOperators.nextblock will return nothing when there are no more blocks to produce.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"If the returned blocks will be represetend by an array of numbers, then SignalOperators.ArrayBlock should be used.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"In other cases, such as when you want to compute individual frames of the block on-the-fly, you should return an object that implements the following two methods.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"nframes Like a signal, each block has some number of frames. Unlike signals, this cannot be an infinite or missing value. The implementation should be a fast, type-stable function.\nSignalOperators.frame Individual frames of the block can be accessed by their index within the block (falling in the range of 1:nframes(block)). This should be a fast, type-stable function. The method is guaranteed to only be called at most once for each index in the block.","category":"page"},{"location":"custom_signal/#Optional-Methods-1","page":"Custom Signals","title":"Optional Methods","text":"","category":"section"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"There are several optional methods you can define for signals as well.","category":"page"},{"location":"custom_signal/#","page":"Custom Signals","title":"Custom Signals","text":"Signal - to enable one more other types to be interpreted as your custom signal type\nSignalOperators.EvalTrait and ToFramerate - to enable custom handling of signal resmapling","category":"page"},{"location":"#SignalOperators.jl-1","page":"Home","title":"SignalOperators.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SignalOperators is a Julia package that aims to provide a clean interface for generating and manipulating signals: typically sounds, but any signal regularly sampled in time can be manipulated.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can install it in Julia by starting the Pkg prompt (hit ]), and using the add command.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(1.2) pkg> add SignalOperators","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As a preview of functionality, here are some example sound generation routines. You can find more detailed information in the manual and reference.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using SignalOperators\nusing SignalOperators.Units # allows the use of dB, Hz, s etc... as unitful values\n\n# a pure tone 20 dB below a power 1 signal, with on and off ramps (for\n# a smooth onset/offset)\nsound1 = Signal(sin,ω=1kHz) |> Until(5s) |> Ramp |> Normpower |> Amplify(-20dB)\n\n# a sound defined by a file, matching the overall power to that of sound1\nsound2 = \"example.wav\" |> Normpower |> Amplify(-20dB)\n\n# a 1kHz sawtooth wave\nsound3 = Signal(ϕ -> ϕ-π,ω=1kHz) |> Ramp |> Normpower |> Amplify(-20dB)\n\n# a 5 Hz amplitude modulated noise\nsound4 = randn |>\n    Amplify(Signal(ϕ -> 0.5sin(ϕ) + 0.5,ω=5Hz)) |>\n    Until(5s) |> Normpower |> Amplify(-20dB)\n\n# a 1kHz tone surrounded by a notch noise\nSNR = 5dB\nx = Signal(sin,ω=1kHz) |> Until(1s) |> Ramp |> Normpower |> Amplify(-20dB + SNR)\ny = Signal(randn) |> Until(1s) |> Filt(Bandstop,0.5kHz,2kHz) |> Normpower |>\n  Amplify(-20dB)\nscene = Mix(x,y)\n\n# write all of the signals to a single file, at 44.1 kHz\nAppend(sound1,sound2,sound3,sound4,scene) |> ToFramerate(44.1kHz) |> sink(\"examples.wav\")\n","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Many thanks to @ssfrr for some great discussions during this PR, and related issues on the SampledSignals package. Those interactions definitely influenced my final design here.","category":"page"}]
}
